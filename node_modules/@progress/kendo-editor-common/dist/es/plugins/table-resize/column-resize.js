import { __assign } from "tslib";
import { Plugin } from 'prosemirror-state';
import { tableNodeTypes, TableMap } from 'prosemirror-tables-ts';
import { Decoration, DecorationSet } from 'prosemirror-view';
import { colgroupAttr } from '../../config/constants';
import { TableView } from './table-view';
import { cellIndexes, domCellAround, otherResizeHandle, otherResizing, parentNode, parseStyle, setNodeStyle, tableColumnResizeKey as key } from './utils';
export function columnResizing() {
    // tslint:disable-next-line:variable-name
    var View = TableView, handleWidth = 5, cellMinWidth = 25;
    var plugin = new Plugin({
        key: key,
        state: {
            init: function (_, state) {
                this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = function (node, view) { return new View(node, view); };
                return new ResizeState(-1, null);
            },
            apply: function (tr, prev) {
                return prev.apply(tr);
            }
        },
        props: {
            attributes: function (state) {
                if (otherResizeHandle(key, state)) {
                    return null;
                }
                var pluginState = key.getState(state);
                return pluginState.activeHandle > -1 ? { class: 'resize-cursor' } : null;
            },
            handleDOMEvents: {
                mousemove: function (view, event) {
                    if (!otherResizing(key, view.state)) {
                        handleMouseMove(view, event, handleWidth);
                    }
                    return false;
                },
                mouseleave: function (view) {
                    handleMouseLeave(view);
                    return false;
                },
                mousedown: function (view, event) {
                    return handleMouseDown(view, event, cellMinWidth);
                }
            },
            decorations: function (state) {
                if (!otherResizing(key, state)) {
                    var pluginState = key.getState(state);
                    if (pluginState.activeHandle > -1) {
                        return handleDecorations(state, pluginState.activeHandle);
                    }
                }
                return DecorationSet.empty;
            },
            nodeViews: {}
        }
    });
    return plugin;
}
function pointsAtCell($pos) {
    return Boolean($pos.parent.type.spec.tableRole === 'row' && $pos.nodeAfter);
}
var ResizeState = /** @class */ (function () {
    function ResizeState(activeHandle, dragging) {
        this.activeHandle = activeHandle;
        this.dragging = dragging;
    }
    ResizeState.prototype.apply = function (tr) {
        var state = this, action = tr.getMeta(key);
        if (action && action.setHandle != null) {
            return new ResizeState(action.setHandle, null);
        }
        if (action && action.setDragging !== undefined) {
            return new ResizeState(state.activeHandle, action.setDragging);
        }
        if (state.activeHandle > -1 && tr.docChanged) {
            var handle = tr.mapping.map(state.activeHandle, -1);
            if (!pointsAtCell(tr.doc.resolve(handle))) {
                handle = -1;
            }
            state = new ResizeState(handle, state.dragging);
        }
        return state;
    };
    return ResizeState;
}());
function handleMouseMove(view, event, handleWidth) {
    var pluginState = key.getState(view.state);
    if (!pluginState.dragging) {
        var target = domCellAround(event.target), cell = -1;
        if (target) {
            var indexes = cellIndexes(target);
            var _a = target.getBoundingClientRect(), left = _a.left, right = _a.right;
            if (Math.abs(event.clientX - left) <= handleWidth && indexes.cellIndex > 0) {
                indexes.cellIndex--;
                cell = edgeCell(view, event, indexes);
            }
            else if (right - event.clientX > 0 && right - event.clientX <= handleWidth) {
                cell = edgeCell(view, event, indexes);
            }
        }
        if (cell !== pluginState.activeHandle) {
            updateHandle(view, cell);
        }
    }
}
function handleMouseLeave(view) {
    var pluginState = key.getState(view.state);
    if (pluginState.activeHandle > -1 && !pluginState.dragging) {
        updateHandle(view, -1);
    }
}
function handleMouseDown(view, event, cellMinWidth) {
    var _a;
    var pluginState = key.getState(view.state);
    if (pluginState.activeHandle === -1 || pluginState.dragging) {
        return false;
    }
    var $cell = view.state.doc.resolve(pluginState.activeHandle);
    var row = $cell.parent;
    var cellIndex = $cell.index();
    var colSpan = 0;
    for (var i = 0; i <= cellIndex; i++) {
        colSpan += row.child(i).attrs.colspan;
    }
    var tableNode = $cell.node($cell.depth - 1);
    var dom = view.domAtPos(pluginState.activeHandle);
    var domCell = dom.node.childNodes[dom.offset];
    var tableDom = domCell.closest('table');
    var col, tableAttrs;
    if (tableNode.attrs[colgroupAttr]) {
        var colgroup = tableDom.firstChild;
        col = colgroup.children[colSpan - 1];
        if (!col.style.width) {
            col.style.width = col.offsetWidth + 'px';
        }
    }
    else {
        var total = 0;
        for (var i = 0; i < row.childCount; i++) {
            total += row.child(i).attrs.colspan;
        }
        var colgroup = document.createElement('colgroup');
        var cols = new Array(total);
        for (var i = 0; i < total; i++) {
            cols[i] = document.createElement('col');
            colgroup.appendChild(cols[i]);
        }
        tableDom.insertBefore(colgroup, tableDom.firstChild);
        col = cols[cellIndex];
        col.style.width = col.offsetWidth + 'px';
        tableAttrs = __assign(__assign({}, tableNode.attrs), (_a = {}, _a[colgroupAttr] = '<colgroup>' + cols.reduce(function (acc, cur) { return acc + cur.outerHTML; }, '') + '</colgroup>', _a));
    }
    var width = parseFloat(col.style.width);
    var tr = view.state.tr.setMeta(key, { setDragging: { startX: event.clientX, startWidth: width } });
    if (!tableDom.style.width) {
        var widths = Array.from(col.parentNode.children).map(function (c) { return c.style.width; });
        if (widths.every(Boolean)) {
            var sum = widths.reduce(function (acc, cur) { return acc + parseFloat(cur); }, 0);
            tableAttrs = setNodeStyle(tableAttrs || tableNode.attrs, 'width', sum + 'px');
        }
    }
    if (tableAttrs) {
        var tablePos = $cell.posAtIndex(0, $cell.depth - 1) - 1;
        tr.setNodeMarkup(tablePos, null, tableAttrs);
    }
    view.dispatch(tr);
    function finish(ev) {
        ev.view.removeEventListener('mouseup', finish);
        ev.view.removeEventListener('mousemove', move);
        var curPluginState = key.getState(view.state);
        if (curPluginState.dragging) {
            var transaction = view.state.tr;
            updateColumnWidth(view, transaction, curPluginState.activeHandle, draggedWidth(curPluginState.dragging, ev, cellMinWidth));
            view.dispatch(transaction.setMeta(key, { setDragging: null }));
        }
    }
    function move(ev) {
        if (!ev.which) {
            return finish(ev);
        }
        var curPluginState = key.getState(view.state);
        var dragged = draggedWidth(curPluginState.dragging, ev, cellMinWidth);
        displayColumnWidth(view, curPluginState.activeHandle, dragged, cellMinWidth);
    }
    event.view.addEventListener('mouseup', finish);
    event.view.addEventListener('mousemove', move);
    event.preventDefault();
    return true;
}
function edgeCell(view, event, indexes) {
    var found = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (!found) {
        return -1;
    }
    var $pos = view.state.doc.resolve(found.pos);
    var parentTable = parentNode($pos, function (n) { return n.type.spec.tableRole === 'table'; });
    if (parentTable === null) {
        return -1;
    }
    var tablePos = $pos.start(parentTable.depth);
    var tableNode = parentTable.node;
    var map = TableMap.get(tableNode);
    var cell = tablePos + map.map[(map.width * indexes.rowIndex) + indexes.cellIndex];
    return cell;
}
function draggedWidth(dragging, event, cellMinWidth) {
    var offset = event.clientX - dragging.startX;
    return Math.max(cellMinWidth, dragging.startWidth + offset);
}
function updateHandle(view, value) {
    var tr = view.state.tr;
    tr.setMeta('addToHistory', false);
    tr.setMeta(key, { setHandle: value });
    view.dispatch(tr);
}
function updateColumnWidth(view, tr, cell, _width) {
    var _a;
    var $cell = view.state.doc.resolve(cell);
    var tableNode = $cell.node(-1), start = $cell.start(-1);
    var tablePos = $cell.posAtIndex(0, $cell.depth - 1) - 1;
    var tableDom = view.nodeDOM(start).closest('table');
    var attrs = tableNode.attrs;
    if (tableNode && attrs[colgroupAttr]) {
        var colgroup = tableDom.firstChild;
        attrs = __assign(__assign({}, attrs), (_a = {}, _a[colgroupAttr] = colgroup.outerHTML, _a));
    }
    var tableDomWidth = tableDom.style.width;
    if (tableDom && tableDomWidth && parseStyle(attrs.style).width !== tableDomWidth) {
        attrs = setNodeStyle(attrs, 'width', tableDomWidth);
        tr.setNodeMarkup(tablePos, null, attrs);
    }
}
function displayColumnWidth(view, cell, width, _cellMinWidth) {
    var $cell = view.state.doc.resolve(cell);
    var table = $cell.node(-1), start = $cell.start(-1);
    var col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
    var dom = view.domAtPos($cell.start(-1)).node;
    if (dom.nodeName !== 'TABLE') {
        dom = dom.closest('table');
    }
    var tableDom = dom;
    var colgroup = tableDom.firstChild;
    var cols = Array.from(colgroup.children);
    cols[col].style.width = width + 'px';
    if (tableDom.style.width) {
        var widths = cols.map(function (c) { return c.style.width; });
        if (widths.every(Boolean)) {
            var sum = widths.reduce(function (acc, cur) { return acc + parseFloat(cur); }, 0);
            tableDom.style.width = sum + 'px';
        }
    }
}
function handleDecorations(state, cell) {
    var decorations = [];
    var $cell = state.doc.resolve(cell);
    var table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);
    var col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;
    for (var row = 0; row < map.height; row++) {
        var index = col + row * map.width - 1;
        // For positions that are have either a different cell or the end
        // of the table to their right, and either the top of the table or
        // a different cell above them, add a decoration
        if ((col === map.width || map.map[index] !== map.map[index + 1]) &&
            (row === 0 || map.map[index - 1] !== map.map[index - 1 - map.width])) {
            var cellPos = map.map[index];
            var pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;
            var dom = document.createElement('div');
            dom.className = 'column-resize-handle';
            decorations.push(Decoration.widget(pos, dom));
        }
    }
    return DecorationSet.create(state.doc, decorations);
}
