import { Plugin } from 'prosemirror-state';
import { tableNodeTypes, TableMap } from 'prosemirror-tables-ts';
import { Decoration, DecorationSet } from 'prosemirror-view';
import { colgroupAttr } from '../../config/constants';
import { TableView } from './table-view';
import { cellIndexes, domCellAround, otherResizeHandle, otherResizing, parentNode, parseStyle, setNodeStyle, tableColumnResizeKey as key } from './utils';
export function columnResizing() {
    // tslint:disable-next-line:variable-name
    const View = TableView, handleWidth = 5, cellMinWidth = 25;
    let plugin = new Plugin({
        key,
        state: {
            init(_, state) {
                this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view) => new View(node, view);
                return new ResizeState(-1, null);
            },
            apply(tr, prev) {
                return prev.apply(tr);
            }
        },
        props: {
            attributes(state) {
                if (otherResizeHandle(key, state)) {
                    return null;
                }
                let pluginState = key.getState(state);
                return pluginState.activeHandle > -1 ? { class: 'resize-cursor' } : null;
            },
            handleDOMEvents: {
                mousemove(view, event) {
                    if (!otherResizing(key, view.state)) {
                        handleMouseMove(view, event, handleWidth);
                    }
                    return false;
                },
                mouseleave(view) {
                    handleMouseLeave(view);
                    return false;
                },
                mousedown(view, event) {
                    return handleMouseDown(view, event, cellMinWidth);
                }
            },
            decorations(state) {
                if (!otherResizing(key, state)) {
                    let pluginState = key.getState(state);
                    if (pluginState.activeHandle > -1) {
                        return handleDecorations(state, pluginState.activeHandle);
                    }
                }
                return DecorationSet.empty;
            },
            nodeViews: {}
        }
    });
    return plugin;
}
function pointsAtCell($pos) {
    return Boolean($pos.parent.type.spec.tableRole === 'row' && $pos.nodeAfter);
}
class ResizeState {
    constructor(activeHandle, dragging) {
        this.activeHandle = activeHandle;
        this.dragging = dragging;
    }
    apply(tr) {
        let state = this, action = tr.getMeta(key);
        if (action && action.setHandle != null) {
            return new ResizeState(action.setHandle, null);
        }
        if (action && action.setDragging !== undefined) {
            return new ResizeState(state.activeHandle, action.setDragging);
        }
        if (state.activeHandle > -1 && tr.docChanged) {
            let handle = tr.mapping.map(state.activeHandle, -1);
            if (!pointsAtCell(tr.doc.resolve(handle))) {
                handle = -1;
            }
            state = new ResizeState(handle, state.dragging);
        }
        return state;
    }
}
function handleMouseMove(view, event, handleWidth) {
    let pluginState = key.getState(view.state);
    if (!pluginState.dragging) {
        let target = domCellAround(event.target), cell = -1;
        if (target) {
            const indexes = cellIndexes(target);
            let { left, right } = target.getBoundingClientRect();
            if (Math.abs(event.clientX - left) <= handleWidth && indexes.cellIndex > 0) {
                indexes.cellIndex--;
                cell = edgeCell(view, event, indexes);
            }
            else if (right - event.clientX > 0 && right - event.clientX <= handleWidth) {
                cell = edgeCell(view, event, indexes);
            }
        }
        if (cell !== pluginState.activeHandle) {
            updateHandle(view, cell);
        }
    }
}
function handleMouseLeave(view) {
    let pluginState = key.getState(view.state);
    if (pluginState.activeHandle > -1 && !pluginState.dragging) {
        updateHandle(view, -1);
    }
}
function handleMouseDown(view, event, cellMinWidth) {
    let pluginState = key.getState(view.state);
    if (pluginState.activeHandle === -1 || pluginState.dragging) {
        return false;
    }
    let $cell = view.state.doc.resolve(pluginState.activeHandle);
    const row = $cell.parent;
    const cellIndex = $cell.index();
    let colSpan = 0;
    for (let i = 0; i <= cellIndex; i++) {
        colSpan += row.child(i).attrs.colspan;
    }
    const tableNode = $cell.node($cell.depth - 1);
    let dom = view.domAtPos(pluginState.activeHandle);
    let domCell = dom.node.childNodes[dom.offset];
    let tableDom = domCell.closest('table');
    let col, tableAttrs;
    if (tableNode.attrs[colgroupAttr]) {
        const colgroup = tableDom.firstChild;
        col = colgroup.children[colSpan - 1];
        if (!col.style.width) {
            col.style.width = col.offsetWidth + 'px';
        }
    }
    else {
        let total = 0;
        for (let i = 0; i < row.childCount; i++) {
            total += row.child(i).attrs.colspan;
        }
        const colgroup = document.createElement('colgroup');
        const cols = new Array(total);
        for (let i = 0; i < total; i++) {
            cols[i] = document.createElement('col');
            colgroup.appendChild(cols[i]);
        }
        tableDom.insertBefore(colgroup, tableDom.firstChild);
        col = cols[cellIndex];
        col.style.width = col.offsetWidth + 'px';
        tableAttrs = Object.assign(Object.assign({}, tableNode.attrs), { [colgroupAttr]: '<colgroup>' + cols.reduce((acc, cur) => acc + cur.outerHTML, '') + '</colgroup>' });
    }
    let width = parseFloat(col.style.width);
    const tr = view.state.tr.setMeta(key, { setDragging: { startX: event.clientX, startWidth: width } });
    if (!tableDom.style.width) {
        const widths = Array.from(col.parentNode.children).map((c) => c.style.width);
        if (widths.every(Boolean)) {
            const sum = widths.reduce((acc, cur) => acc + parseFloat(cur), 0);
            tableAttrs = setNodeStyle(tableAttrs || tableNode.attrs, 'width', sum + 'px');
        }
    }
    if (tableAttrs) {
        const tablePos = $cell.posAtIndex(0, $cell.depth - 1) - 1;
        tr.setNodeMarkup(tablePos, null, tableAttrs);
    }
    view.dispatch(tr);
    function finish(ev) {
        ev.view.removeEventListener('mouseup', finish);
        ev.view.removeEventListener('mousemove', move);
        let curPluginState = key.getState(view.state);
        if (curPluginState.dragging) {
            const transaction = view.state.tr;
            updateColumnWidth(view, transaction, curPluginState.activeHandle, draggedWidth(curPluginState.dragging, ev, cellMinWidth));
            view.dispatch(transaction.setMeta(key, { setDragging: null }));
        }
    }
    function move(ev) {
        if (!ev.which) {
            return finish(ev);
        }
        let curPluginState = key.getState(view.state);
        let dragged = draggedWidth(curPluginState.dragging, ev, cellMinWidth);
        displayColumnWidth(view, curPluginState.activeHandle, dragged, cellMinWidth);
    }
    event.view.addEventListener('mouseup', finish);
    event.view.addEventListener('mousemove', move);
    event.preventDefault();
    return true;
}
function edgeCell(view, event, indexes) {
    let found = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (!found) {
        return -1;
    }
    let $pos = view.state.doc.resolve(found.pos);
    let parentTable = parentNode($pos, n => n.type.spec.tableRole === 'table');
    if (parentTable === null) {
        return -1;
    }
    let tablePos = $pos.start(parentTable.depth);
    const tableNode = parentTable.node;
    const map = TableMap.get(tableNode);
    const cell = tablePos + map.map[(map.width * indexes.rowIndex) + indexes.cellIndex];
    return cell;
}
function draggedWidth(dragging, event, cellMinWidth) {
    let offset = event.clientX - dragging.startX;
    return Math.max(cellMinWidth, dragging.startWidth + offset);
}
function updateHandle(view, value) {
    const tr = view.state.tr;
    tr.setMeta('addToHistory', false);
    tr.setMeta(key, { setHandle: value });
    view.dispatch(tr);
}
function updateColumnWidth(view, tr, cell, _width) {
    let $cell = view.state.doc.resolve(cell);
    let tableNode = $cell.node(-1), start = $cell.start(-1);
    const tablePos = $cell.posAtIndex(0, $cell.depth - 1) - 1;
    const tableDom = view.nodeDOM(start).closest('table');
    let attrs = tableNode.attrs;
    if (tableNode && attrs[colgroupAttr]) {
        const colgroup = tableDom.firstChild;
        attrs = Object.assign(Object.assign({}, attrs), { [colgroupAttr]: colgroup.outerHTML });
    }
    const tableDomWidth = tableDom.style.width;
    if (tableDom && tableDomWidth && parseStyle(attrs.style).width !== tableDomWidth) {
        attrs = setNodeStyle(attrs, 'width', tableDomWidth);
        tr.setNodeMarkup(tablePos, null, attrs);
    }
}
function displayColumnWidth(view, cell, width, _cellMinWidth) {
    let $cell = view.state.doc.resolve(cell);
    let table = $cell.node(-1), start = $cell.start(-1);
    let col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
    let dom = view.domAtPos($cell.start(-1)).node;
    if (dom.nodeName !== 'TABLE') {
        dom = dom.closest('table');
    }
    const tableDom = dom;
    const colgroup = tableDom.firstChild;
    const cols = Array.from(colgroup.children);
    cols[col].style.width = width + 'px';
    if (tableDom.style.width) {
        const widths = cols.map(c => c.style.width);
        if (widths.every(Boolean)) {
            const sum = widths.reduce((acc, cur) => acc + parseFloat(cur), 0);
            tableDom.style.width = sum + 'px';
        }
    }
}
function handleDecorations(state, cell) {
    let decorations = [];
    let $cell = state.doc.resolve(cell);
    let table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);
    let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;
    for (let row = 0; row < map.height; row++) {
        let index = col + row * map.width - 1;
        // For positions that are have either a different cell or the end
        // of the table to their right, and either the top of the table or
        // a different cell above them, add a decoration
        if ((col === map.width || map.map[index] !== map.map[index + 1]) &&
            (row === 0 || map.map[index - 1] !== map.map[index - 1 - map.width])) {
            let cellPos = map.map[index];
            let pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;
            let dom = document.createElement('div');
            dom.className = 'column-resize-handle';
            decorations.push(Decoration.widget(pos, dom));
        }
    }
    return DecorationSet.create(state.doc, decorations);
}
