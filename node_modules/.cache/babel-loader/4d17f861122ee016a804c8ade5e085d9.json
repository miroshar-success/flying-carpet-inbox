{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar findAncestorOffsetKey = require(\"./findAncestorOffsetKey\");\n\nvar getSelectionOffsetKeyForNode = require(\"./getSelectionOffsetKeyForNode\");\n\nvar getUpdatedSelectionState = require(\"./getUpdatedSelectionState\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar isElement = require(\"./isElement\");\n\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\n/**\n * Convert the current selection range to an anchor/focus pair of offset keys\n * and values that can be interpreted by components.\n */\n\n\nfunction getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;\n  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE; // If the selection range lies only on text nodes, the task is simple.\n  // Find the nearest offset-aware elements and use the\n  // offset values supplied by the selection range.\n\n  if (anchorIsTextNode && focusIsTextNode) {\n    return {\n      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),\n      needsRecovery: false\n    };\n  }\n\n  var anchorPoint = null;\n  var focusPoint = null;\n  var needsRecovery = true; // An element is selected. Convert this selection range into leaf offset\n  // keys and offset values for consumption at the component level. This\n  // is common in Firefox, where select-all and triple click behavior leads\n  // to entire elements being selected.\n  //\n  // Note that we use the `needsRecovery` parameter in the callback here. This\n  // is because when certain elements are selected, the behavior for subsequent\n  // cursor movement (e.g. via arrow keys) is uncertain and may not match\n  // expectations at the component level. For example, if an entire <div> is\n  // selected and the user presses the right arrow, Firefox keeps the selection\n  // on the <div>. If we allow subsequent keypresses to insert characters\n  // natively, they will be inserted into a browser-created text node to the\n  // right of that <div>. This is obviously undesirable.\n  //\n  // With the `needsRecovery` flag, we inform the caller that it is responsible\n  // for manually setting the selection state on the rendered document to\n  // ensure proper selection state maintenance.\n\n  if (anchorIsTextNode) {\n    anchorPoint = {\n      key: nullthrows(findAncestorOffsetKey(anchorNode)),\n      offset: anchorOffset\n    };\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n  } else if (focusIsTextNode) {\n    focusPoint = {\n      key: nullthrows(findAncestorOffsetKey(focusNode)),\n      offset: focusOffset\n    };\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n  } else {\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset); // If the selection is collapsed on an empty block, don't force recovery.\n    // This way, on arrow key selection changes, the browser can move the\n    // cursor from a non-zero offset on one block, through empty blocks,\n    // to a matching non-zero offset on other text blocks.\n\n    if (anchorNode === focusNode && anchorOffset === focusOffset) {\n      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';\n    }\n  }\n\n  return {\n    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),\n    needsRecovery: needsRecovery\n  };\n}\n/**\n * Identify the first leaf descendant for the given node.\n */\n\n\nfunction getFirstLeaf(node) {\n  while (node.firstChild && ( // data-blocks has no offset\n  isElement(node.firstChild) && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.firstChild))) {\n    node = node.firstChild;\n  }\n\n  return node;\n}\n/**\n * Identify the last leaf descendant for the given node.\n */\n\n\nfunction getLastLeaf(node) {\n  while (node.lastChild && ( // data-blocks has no offset\n  isElement(node.lastChild) && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.lastChild))) {\n    node = node.lastChild;\n  }\n\n  return node;\n}\n\nfunction getPointForNonTextNode(editorRoot, startNode, childOffset) {\n  var node = startNode;\n  var offsetKey = findAncestorOffsetKey(node);\n  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unknown node in selection range.') : invariant(false) : void 0; // If the editorRoot is the selection, step downward into the content\n  // wrapper.\n\n  if (editorRoot === node) {\n    node = node.firstChild;\n    !isElement(node) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid DraftEditorContents node.') : invariant(false) : void 0;\n    var castedNode = node; // assignment only added for flow :/\n    // otherwise it throws in line 200 saying that node can be null or undefined\n\n    node = castedNode;\n    !(node.getAttribute('data-contents') === 'true') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : void 0;\n\n    if (childOffset > 0) {\n      childOffset = node.childNodes.length;\n    }\n  } // If the child offset is zero and we have an offset key, we're done.\n  // If there's no offset key because the entire editor is selected,\n  // find the leftmost (\"first\") leaf in the tree and use that as the offset\n  // key.\n\n\n  if (childOffset === 0) {\n    var key = null;\n\n    if (offsetKey != null) {\n      key = offsetKey;\n    } else {\n      var firstLeaf = getFirstLeaf(node);\n      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));\n    }\n\n    return {\n      key: key,\n      offset: 0\n    };\n  }\n\n  var nodeBeforeCursor = node.childNodes[childOffset - 1];\n  var leafKey = null;\n  var textLength = null;\n\n  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {\n    // Our target node may be a leaf or a text node, in which case we're\n    // already where we want to be and can just use the child's length as\n    // our offset.\n    leafKey = nullthrows(offsetKey);\n    textLength = getTextContentLength(nodeBeforeCursor);\n  } else {\n    // Otherwise, we'll look at the child to the left of the cursor and find\n    // the last leaf node in its subtree.\n    var lastLeaf = getLastLeaf(nodeBeforeCursor);\n    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));\n    textLength = getTextContentLength(lastLeaf);\n  }\n\n  return {\n    key: leafKey,\n    offset: textLength\n  };\n}\n/**\n * Return the length of a node's textContent, regarding single newline\n * characters as zero-length. This allows us to avoid problems with identifying\n * the correct selection offset for empty blocks in IE, in which we\n * render newlines instead of break tags.\n */\n\n\nfunction getTextContentLength(node) {\n  var textContent = node.textContent;\n  return textContent === '\\n' ? 0 : textContent.length;\n}\n\nmodule.exports = getDraftEditorSelectionWithNodes;","map":{"version":3,"sources":["D:/workspace/flying-assess/flyingcarpet-shared-inbox/node_modules/draft-js/lib/getDraftEditorSelectionWithNodes.js"],"names":["findAncestorOffsetKey","require","getSelectionOffsetKeyForNode","getUpdatedSelectionState","invariant","isElement","nullthrows","getDraftEditorSelectionWithNodes","editorState","root","anchorNode","anchorOffset","focusNode","focusOffset","anchorIsTextNode","nodeType","Node","TEXT_NODE","focusIsTextNode","selectionState","needsRecovery","anchorPoint","focusPoint","key","offset","getPointForNonTextNode","firstChild","nodeName","getFirstLeaf","node","getAttribute","getLastLeaf","lastChild","editorRoot","startNode","childOffset","offsetKey","process","env","NODE_ENV","castedNode","childNodes","length","firstLeaf","nodeBeforeCursor","leafKey","textLength","getTextContentLength","lastLeaf","textContent","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,qBAAqB,GAAGC,OAAO,CAAC,yBAAD,CAAnC;;AAEA,IAAIC,4BAA4B,GAAGD,OAAO,CAAC,gCAAD,CAA1C;;AAEA,IAAIE,wBAAwB,GAAGF,OAAO,CAAC,4BAAD,CAAtC;;AAEA,IAAIG,SAAS,GAAGH,OAAO,CAAC,oBAAD,CAAvB;;AAEA,IAAII,SAAS,GAAGJ,OAAO,CAAC,aAAD,CAAvB;;AAEA,IAAIK,UAAU,GAAGL,OAAO,CAAC,qBAAD,CAAxB;AAEA;AACA;AACA;AACA;;;AACA,SAASM,gCAAT,CAA0CC,WAA1C,EAAuDC,IAAvD,EAA6DC,UAA7D,EAAyEC,YAAzE,EAAuFC,SAAvF,EAAkGC,WAAlG,EAA+G;AAC7G,MAAIC,gBAAgB,GAAGJ,UAAU,CAACK,QAAX,KAAwBC,IAAI,CAACC,SAApD;AACA,MAAIC,eAAe,GAAGN,SAAS,CAACG,QAAV,KAAuBC,IAAI,CAACC,SAAlD,CAF6G,CAEhD;AAC7D;AACA;;AAEA,MAAIH,gBAAgB,IAAII,eAAxB,EAAyC;AACvC,WAAO;AACLC,MAAAA,cAAc,EAAEhB,wBAAwB,CAACK,WAAD,EAAcF,UAAU,CAACN,qBAAqB,CAACU,UAAD,CAAtB,CAAxB,EAA6DC,YAA7D,EAA2EL,UAAU,CAACN,qBAAqB,CAACY,SAAD,CAAtB,CAArF,EAAyHC,WAAzH,CADnC;AAELO,MAAAA,aAAa,EAAE;AAFV,KAAP;AAID;;AAED,MAAIC,WAAW,GAAG,IAAlB;AACA,MAAIC,UAAU,GAAG,IAAjB;AACA,MAAIF,aAAa,GAAG,IAApB,CAf6G,CAenF;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAIN,gBAAJ,EAAsB;AACpBO,IAAAA,WAAW,GAAG;AACZE,MAAAA,GAAG,EAAEjB,UAAU,CAACN,qBAAqB,CAACU,UAAD,CAAtB,CADH;AAEZc,MAAAA,MAAM,EAAEb;AAFI,KAAd;AAIAW,IAAAA,UAAU,GAAGG,sBAAsB,CAAChB,IAAD,EAAOG,SAAP,EAAkBC,WAAlB,CAAnC;AACD,GAND,MAMO,IAAIK,eAAJ,EAAqB;AAC1BI,IAAAA,UAAU,GAAG;AACXC,MAAAA,GAAG,EAAEjB,UAAU,CAACN,qBAAqB,CAACY,SAAD,CAAtB,CADJ;AAEXY,MAAAA,MAAM,EAAEX;AAFG,KAAb;AAIAQ,IAAAA,WAAW,GAAGI,sBAAsB,CAAChB,IAAD,EAAOC,UAAP,EAAmBC,YAAnB,CAApC;AACD,GANM,MAMA;AACLU,IAAAA,WAAW,GAAGI,sBAAsB,CAAChB,IAAD,EAAOC,UAAP,EAAmBC,YAAnB,CAApC;AACAW,IAAAA,UAAU,GAAGG,sBAAsB,CAAChB,IAAD,EAAOG,SAAP,EAAkBC,WAAlB,CAAnC,CAFK,CAE8D;AACnE;AACA;AACA;;AAEA,QAAIH,UAAU,KAAKE,SAAf,IAA4BD,YAAY,KAAKE,WAAjD,EAA8D;AAC5DO,MAAAA,aAAa,GAAG,CAAC,CAACV,UAAU,CAACgB,UAAb,IAA2BhB,UAAU,CAACgB,UAAX,CAAsBC,QAAtB,KAAmC,IAA9E;AACD;AACF;;AAED,SAAO;AACLR,IAAAA,cAAc,EAAEhB,wBAAwB,CAACK,WAAD,EAAca,WAAW,CAACE,GAA1B,EAA+BF,WAAW,CAACG,MAA3C,EAAmDF,UAAU,CAACC,GAA9D,EAAmED,UAAU,CAACE,MAA9E,CADnC;AAELJ,IAAAA,aAAa,EAAEA;AAFV,GAAP;AAID;AACD;AACA;AACA;;;AAGA,SAASQ,YAAT,CAAsBC,IAAtB,EAA4B;AAC1B,SAAOA,IAAI,CAACH,UAAL,MAAqB;AAC5BrB,EAAAA,SAAS,CAACwB,IAAI,CAACH,UAAN,CAAT,IAA8BG,IAAI,CAACH,UAAL,CAAgBI,YAAhB,CAA6B,aAA7B,MAAgD,MAA9E,IAAwF5B,4BAA4B,CAAC2B,IAAI,CAACH,UAAN,CAD7G,CAAP,EACwI;AACtIG,IAAAA,IAAI,GAAGA,IAAI,CAACH,UAAZ;AACD;;AAED,SAAOG,IAAP;AACD;AACD;AACA;AACA;;;AAGA,SAASE,WAAT,CAAqBF,IAArB,EAA2B;AACzB,SAAOA,IAAI,CAACG,SAAL,MAAoB;AAC3B3B,EAAAA,SAAS,CAACwB,IAAI,CAACG,SAAN,CAAT,IAA6BH,IAAI,CAACG,SAAL,CAAeF,YAAf,CAA4B,aAA5B,MAA+C,MAA5E,IAAsF5B,4BAA4B,CAAC2B,IAAI,CAACG,SAAN,CAD3G,CAAP,EACqI;AACnIH,IAAAA,IAAI,GAAGA,IAAI,CAACG,SAAZ;AACD;;AAED,SAAOH,IAAP;AACD;;AAED,SAASJ,sBAAT,CAAgCQ,UAAhC,EAA4CC,SAA5C,EAAuDC,WAAvD,EAAoE;AAClE,MAAIN,IAAI,GAAGK,SAAX;AACA,MAAIE,SAAS,GAAGpC,qBAAqB,CAAC6B,IAAD,CAArC;AACA,IAAEO,SAAS,IAAI,IAAb,IAAqBH,UAAU,KAAKA,UAAU,KAAKJ,IAAf,IAAuBI,UAAU,CAACP,UAAX,KAA0BG,IAAtD,CAAjC,IAAgGQ,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnC,SAAS,CAAC,KAAD,EAAQ,kCAAR,CAAjD,GAA+FA,SAAS,CAAC,KAAD,CAAxM,GAAkN,KAAK,CAAvN,CAHkE,CAGwJ;AAC1N;;AAEA,MAAI6B,UAAU,KAAKJ,IAAnB,EAAyB;AACvBA,IAAAA,IAAI,GAAGA,IAAI,CAACH,UAAZ;AACA,KAACrB,SAAS,CAACwB,IAAD,CAAV,GAAmBQ,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnC,SAAS,CAAC,KAAD,EAAQ,mCAAR,CAAjD,GAAgGA,SAAS,CAAC,KAAD,CAA5H,GAAsI,KAAK,CAA3I;AACA,QAAIoC,UAAU,GAAGX,IAAjB,CAHuB,CAGA;AACvB;;AAEAA,IAAAA,IAAI,GAAGW,UAAP;AACA,MAAEX,IAAI,CAACC,YAAL,CAAkB,eAAlB,MAAuC,MAAzC,IAAmDO,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnC,SAAS,CAAC,KAAD,EAAQ,wCAAR,CAAjD,GAAqGA,SAAS,CAAC,KAAD,CAAjK,GAA2K,KAAK,CAAhL;;AAEA,QAAI+B,WAAW,GAAG,CAAlB,EAAqB;AACnBA,MAAAA,WAAW,GAAGN,IAAI,CAACY,UAAL,CAAgBC,MAA9B;AACD;AACF,GAlBiE,CAkBhE;AACF;AACA;AACA;;;AAGA,MAAIP,WAAW,KAAK,CAApB,EAAuB;AACrB,QAAIZ,GAAG,GAAG,IAAV;;AAEA,QAAIa,SAAS,IAAI,IAAjB,EAAuB;AACrBb,MAAAA,GAAG,GAAGa,SAAN;AACD,KAFD,MAEO;AACL,UAAIO,SAAS,GAAGf,YAAY,CAACC,IAAD,CAA5B;AACAN,MAAAA,GAAG,GAAGjB,UAAU,CAACJ,4BAA4B,CAACyC,SAAD,CAA7B,CAAhB;AACD;;AAED,WAAO;AACLpB,MAAAA,GAAG,EAAEA,GADA;AAELC,MAAAA,MAAM,EAAE;AAFH,KAAP;AAID;;AAED,MAAIoB,gBAAgB,GAAGf,IAAI,CAACY,UAAL,CAAgBN,WAAW,GAAG,CAA9B,CAAvB;AACA,MAAIU,OAAO,GAAG,IAAd;AACA,MAAIC,UAAU,GAAG,IAAjB;;AAEA,MAAI,CAAC5C,4BAA4B,CAAC0C,gBAAD,CAAjC,EAAqD;AACnD;AACA;AACA;AACAC,IAAAA,OAAO,GAAGvC,UAAU,CAAC8B,SAAD,CAApB;AACAU,IAAAA,UAAU,GAAGC,oBAAoB,CAACH,gBAAD,CAAjC;AACD,GAND,MAMO;AACL;AACA;AACA,QAAII,QAAQ,GAAGjB,WAAW,CAACa,gBAAD,CAA1B;AACAC,IAAAA,OAAO,GAAGvC,UAAU,CAACJ,4BAA4B,CAAC8C,QAAD,CAA7B,CAApB;AACAF,IAAAA,UAAU,GAAGC,oBAAoB,CAACC,QAAD,CAAjC;AACD;;AAED,SAAO;AACLzB,IAAAA,GAAG,EAAEsB,OADA;AAELrB,IAAAA,MAAM,EAAEsB;AAFH,GAAP;AAID;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,oBAAT,CAA8BlB,IAA9B,EAAoC;AAClC,MAAIoB,WAAW,GAAGpB,IAAI,CAACoB,WAAvB;AACA,SAAOA,WAAW,KAAK,IAAhB,GAAuB,CAAvB,GAA2BA,WAAW,CAACP,MAA9C;AACD;;AAEDQ,MAAM,CAACC,OAAP,GAAiB5C,gCAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar findAncestorOffsetKey = require(\"./findAncestorOffsetKey\");\n\nvar getSelectionOffsetKeyForNode = require(\"./getSelectionOffsetKeyForNode\");\n\nvar getUpdatedSelectionState = require(\"./getUpdatedSelectionState\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar isElement = require(\"./isElement\");\n\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\n\n/**\n * Convert the current selection range to an anchor/focus pair of offset keys\n * and values that can be interpreted by components.\n */\nfunction getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;\n  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE; // If the selection range lies only on text nodes, the task is simple.\n  // Find the nearest offset-aware elements and use the\n  // offset values supplied by the selection range.\n\n  if (anchorIsTextNode && focusIsTextNode) {\n    return {\n      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),\n      needsRecovery: false\n    };\n  }\n\n  var anchorPoint = null;\n  var focusPoint = null;\n  var needsRecovery = true; // An element is selected. Convert this selection range into leaf offset\n  // keys and offset values for consumption at the component level. This\n  // is common in Firefox, where select-all and triple click behavior leads\n  // to entire elements being selected.\n  //\n  // Note that we use the `needsRecovery` parameter in the callback here. This\n  // is because when certain elements are selected, the behavior for subsequent\n  // cursor movement (e.g. via arrow keys) is uncertain and may not match\n  // expectations at the component level. For example, if an entire <div> is\n  // selected and the user presses the right arrow, Firefox keeps the selection\n  // on the <div>. If we allow subsequent keypresses to insert characters\n  // natively, they will be inserted into a browser-created text node to the\n  // right of that <div>. This is obviously undesirable.\n  //\n  // With the `needsRecovery` flag, we inform the caller that it is responsible\n  // for manually setting the selection state on the rendered document to\n  // ensure proper selection state maintenance.\n\n  if (anchorIsTextNode) {\n    anchorPoint = {\n      key: nullthrows(findAncestorOffsetKey(anchorNode)),\n      offset: anchorOffset\n    };\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n  } else if (focusIsTextNode) {\n    focusPoint = {\n      key: nullthrows(findAncestorOffsetKey(focusNode)),\n      offset: focusOffset\n    };\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n  } else {\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset); // If the selection is collapsed on an empty block, don't force recovery.\n    // This way, on arrow key selection changes, the browser can move the\n    // cursor from a non-zero offset on one block, through empty blocks,\n    // to a matching non-zero offset on other text blocks.\n\n    if (anchorNode === focusNode && anchorOffset === focusOffset) {\n      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';\n    }\n  }\n\n  return {\n    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),\n    needsRecovery: needsRecovery\n  };\n}\n/**\n * Identify the first leaf descendant for the given node.\n */\n\n\nfunction getFirstLeaf(node) {\n  while (node.firstChild && ( // data-blocks has no offset\n  isElement(node.firstChild) && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.firstChild))) {\n    node = node.firstChild;\n  }\n\n  return node;\n}\n/**\n * Identify the last leaf descendant for the given node.\n */\n\n\nfunction getLastLeaf(node) {\n  while (node.lastChild && ( // data-blocks has no offset\n  isElement(node.lastChild) && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.lastChild))) {\n    node = node.lastChild;\n  }\n\n  return node;\n}\n\nfunction getPointForNonTextNode(editorRoot, startNode, childOffset) {\n  var node = startNode;\n  var offsetKey = findAncestorOffsetKey(node);\n  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unknown node in selection range.') : invariant(false) : void 0; // If the editorRoot is the selection, step downward into the content\n  // wrapper.\n\n  if (editorRoot === node) {\n    node = node.firstChild;\n    !isElement(node) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid DraftEditorContents node.') : invariant(false) : void 0;\n    var castedNode = node; // assignment only added for flow :/\n    // otherwise it throws in line 200 saying that node can be null or undefined\n\n    node = castedNode;\n    !(node.getAttribute('data-contents') === 'true') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : void 0;\n\n    if (childOffset > 0) {\n      childOffset = node.childNodes.length;\n    }\n  } // If the child offset is zero and we have an offset key, we're done.\n  // If there's no offset key because the entire editor is selected,\n  // find the leftmost (\"first\") leaf in the tree and use that as the offset\n  // key.\n\n\n  if (childOffset === 0) {\n    var key = null;\n\n    if (offsetKey != null) {\n      key = offsetKey;\n    } else {\n      var firstLeaf = getFirstLeaf(node);\n      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));\n    }\n\n    return {\n      key: key,\n      offset: 0\n    };\n  }\n\n  var nodeBeforeCursor = node.childNodes[childOffset - 1];\n  var leafKey = null;\n  var textLength = null;\n\n  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {\n    // Our target node may be a leaf or a text node, in which case we're\n    // already where we want to be and can just use the child's length as\n    // our offset.\n    leafKey = nullthrows(offsetKey);\n    textLength = getTextContentLength(nodeBeforeCursor);\n  } else {\n    // Otherwise, we'll look at the child to the left of the cursor and find\n    // the last leaf node in its subtree.\n    var lastLeaf = getLastLeaf(nodeBeforeCursor);\n    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));\n    textLength = getTextContentLength(lastLeaf);\n  }\n\n  return {\n    key: leafKey,\n    offset: textLength\n  };\n}\n/**\n * Return the length of a node's textContent, regarding single newline\n * characters as zero-length. This allows us to avoid problems with identifying\n * the correct selection offset for empty blocks in IE, in which we\n * render newlines instead of break tags.\n */\n\n\nfunction getTextContentLength(node) {\n  var textContent = node.textContent;\n  return textContent === '\\n' ? 0 : textContent.length;\n}\n\nmodule.exports = getDraftEditorSelectionWithNodes;"]},"metadata":{},"sourceType":"script"}