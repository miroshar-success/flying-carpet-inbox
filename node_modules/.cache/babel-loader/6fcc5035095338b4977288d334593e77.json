{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.draftjsToHtml = factory());\n})(this, function () {\n  'use strict';\n  /**\n  * Utility function to execute callback for eack key->value pair.\n  */\n\n  function forEach(obj, callback) {\n    if (obj) {\n      for (var key in obj) {\n        // eslint-disable-line no-restricted-syntax\n        if ({}.hasOwnProperty.call(obj, key)) {\n          callback(key, obj[key]);\n        }\n      }\n    }\n  }\n  /**\n  * The function returns true if the string passed to it has no content.\n  */\n\n\n  function isEmptyString(str) {\n    if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  * Mapping block-type to corresponding html tag.\n  */\n\n\n  var blockTypesMapping = {\n    unstyled: 'p',\n    'header-one': 'h1',\n    'header-two': 'h2',\n    'header-three': 'h3',\n    'header-four': 'h4',\n    'header-five': 'h5',\n    'header-six': 'h6',\n    'unordered-list-item': 'ul',\n    'ordered-list-item': 'ol',\n    blockquote: 'blockquote',\n    code: 'pre'\n  };\n  /**\n  * Function will return HTML tag for a block.\n  */\n\n  function getBlockTag(type) {\n    return type && blockTypesMapping[type];\n  }\n  /**\n  * Function will return style string for a block.\n  */\n\n\n  function getBlockStyle(data) {\n    var styles = '';\n    forEach(data, function (key, value) {\n      if (value) {\n        styles += \"\".concat(key, \":\").concat(value, \";\");\n      }\n    });\n    return styles;\n  }\n  /**\n  * The function returns an array of hashtag-sections in blocks.\n  * These will be areas in block which have hashtags applicable to them.\n  */\n\n\n  function getHashtagRanges(blockText, hashtagConfig) {\n    var sections = [];\n\n    if (hashtagConfig) {\n      var counter = 0;\n      var startIndex = 0;\n      var text = blockText;\n      var trigger = hashtagConfig.trigger || '#';\n      var separator = hashtagConfig.separator || ' ';\n\n      for (; text.length > 0 && startIndex >= 0;) {\n        if (text[0] === trigger) {\n          startIndex = 0;\n          counter = 0;\n          text = text.substr(trigger.length);\n        } else {\n          startIndex = text.indexOf(separator + trigger);\n\n          if (startIndex >= 0) {\n            text = text.substr(startIndex + (separator + trigger).length);\n            counter += startIndex + separator.length;\n          }\n        }\n\n        if (startIndex >= 0) {\n          var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n          var hashtag = text.substr(0, endIndex);\n\n          if (hashtag && hashtag.length > 0) {\n            sections.push({\n              offset: counter,\n              length: hashtag.length + trigger.length,\n              type: 'HASHTAG'\n            });\n          }\n\n          counter += trigger.length;\n        }\n      }\n    }\n\n    return sections;\n  }\n  /**\n  * The function returns an array of entity-sections in blocks.\n  * These will be areas in block which have same entity or no entity applicable to them.\n  */\n\n\n  function getSections(block, hashtagConfig) {\n    var sections = [];\n    var lastOffset = 0;\n    var sectionRanges = block.entityRanges.map(function (range) {\n      var offset = range.offset,\n          length = range.length,\n          key = range.key;\n      return {\n        offset: offset,\n        length: length,\n        key: key,\n        type: 'ENTITY'\n      };\n    });\n    sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n    sectionRanges = sectionRanges.sort(function (s1, s2) {\n      return s1.offset - s2.offset;\n    });\n    sectionRanges.forEach(function (r) {\n      if (r.offset > lastOffset) {\n        sections.push({\n          start: lastOffset,\n          end: r.offset\n        });\n      }\n\n      sections.push({\n        start: r.offset,\n        end: r.offset + r.length,\n        entityKey: r.key,\n        type: r.type\n      });\n      lastOffset = r.offset + r.length;\n    });\n\n    if (lastOffset < block.text.length) {\n      sections.push({\n        start: lastOffset,\n        end: block.text.length\n      });\n    }\n\n    return sections;\n  }\n  /**\n  * Function to check if the block is an atomic entity block.\n  */\n\n\n  function isAtomicEntityBlock(block) {\n    if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  * The function will return array of inline styles applicable to the block.\n  */\n\n\n  function getStyleArrayForBlock(block) {\n    var text = block.text,\n        inlineStyleRanges = block.inlineStyleRanges;\n    var inlineStyles = {\n      BOLD: new Array(text.length),\n      ITALIC: new Array(text.length),\n      UNDERLINE: new Array(text.length),\n      STRIKETHROUGH: new Array(text.length),\n      CODE: new Array(text.length),\n      SUPERSCRIPT: new Array(text.length),\n      SUBSCRIPT: new Array(text.length),\n      COLOR: new Array(text.length),\n      BGCOLOR: new Array(text.length),\n      FONTSIZE: new Array(text.length),\n      FONTFAMILY: new Array(text.length),\n      length: text.length\n    };\n\n    if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n      inlineStyleRanges.forEach(function (range) {\n        var offset = range.offset;\n        var length = offset + range.length;\n\n        for (var i = offset; i < length; i += 1) {\n          if (range.style.indexOf('color-') === 0) {\n            inlineStyles.COLOR[i] = range.style.substring(6);\n          } else if (range.style.indexOf('bgcolor-') === 0) {\n            inlineStyles.BGCOLOR[i] = range.style.substring(8);\n          } else if (range.style.indexOf('fontsize-') === 0) {\n            inlineStyles.FONTSIZE[i] = range.style.substring(9);\n          } else if (range.style.indexOf('fontfamily-') === 0) {\n            inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n          } else if (inlineStyles[range.style]) {\n            inlineStyles[range.style][i] = true;\n          }\n        }\n      });\n    }\n\n    return inlineStyles;\n  }\n  /**\n  * The function will return inline style applicable at some offset within a block.\n  */\n\n\n  function getStylesAtOffset(inlineStyles, offset) {\n    var styles = {};\n\n    if (inlineStyles.COLOR[offset]) {\n      styles.COLOR = inlineStyles.COLOR[offset];\n    }\n\n    if (inlineStyles.BGCOLOR[offset]) {\n      styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n    }\n\n    if (inlineStyles.FONTSIZE[offset]) {\n      styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n    }\n\n    if (inlineStyles.FONTFAMILY[offset]) {\n      styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n    }\n\n    if (inlineStyles.UNDERLINE[offset]) {\n      styles.UNDERLINE = true;\n    }\n\n    if (inlineStyles.ITALIC[offset]) {\n      styles.ITALIC = true;\n    }\n\n    if (inlineStyles.BOLD[offset]) {\n      styles.BOLD = true;\n    }\n\n    if (inlineStyles.STRIKETHROUGH[offset]) {\n      styles.STRIKETHROUGH = true;\n    }\n\n    if (inlineStyles.CODE[offset]) {\n      styles.CODE = true;\n    }\n\n    if (inlineStyles.SUBSCRIPT[offset]) {\n      styles.SUBSCRIPT = true;\n    }\n\n    if (inlineStyles.SUPERSCRIPT[offset]) {\n      styles.SUPERSCRIPT = true;\n    }\n\n    return styles;\n  }\n  /**\n  * Function returns true for a set of styles if the value of these styles at an offset\n  * are same as that on the previous offset.\n  */\n\n\n  function sameStyleAsPrevious(inlineStyles, styles, index) {\n    var sameStyled = true;\n\n    if (index > 0 && index < inlineStyles.length) {\n      styles.forEach(function (style) {\n        sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n      });\n    } else {\n      sameStyled = false;\n    }\n\n    return sameStyled;\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n\n  function addInlineStyleMarkup(style, content) {\n    if (style === 'BOLD') {\n      return \"<strong>\".concat(content, \"</strong>\");\n    }\n\n    if (style === 'ITALIC') {\n      return \"<em>\".concat(content, \"</em>\");\n    }\n\n    if (style === 'UNDERLINE') {\n      return \"<ins>\".concat(content, \"</ins>\");\n    }\n\n    if (style === 'STRIKETHROUGH') {\n      return \"<del>\".concat(content, \"</del>\");\n    }\n\n    if (style === 'CODE') {\n      return \"<code>\".concat(content, \"</code>\");\n    }\n\n    if (style === 'SUPERSCRIPT') {\n      return \"<sup>\".concat(content, \"</sup>\");\n    }\n\n    if (style === 'SUBSCRIPT') {\n      return \"<sub>\".concat(content, \"</sub>\");\n    }\n\n    return content;\n  }\n  /**\n  * The function returns text for given section of block after doing required character replacements.\n  */\n\n\n  function getSectionText(text) {\n    if (text && text.length > 0) {\n      var chars = text.map(function (ch) {\n        switch (ch) {\n          case '\\n':\n            return '<br>';\n\n          case '&':\n            return '&amp;';\n\n          case '<':\n            return '&lt;';\n\n          case '>':\n            return '&gt;';\n\n          default:\n            return ch;\n        }\n      });\n      return chars.join('');\n    }\n\n    return '';\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n\n  function addStylePropertyMarkup(styles, text) {\n    if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n      var styleString = 'style=\"';\n\n      if (styles.COLOR) {\n        styleString += \"color: \".concat(styles.COLOR, \";\");\n      }\n\n      if (styles.BGCOLOR) {\n        styleString += \"background-color: \".concat(styles.BGCOLOR, \";\");\n      }\n\n      if (styles.FONTSIZE) {\n        styleString += \"font-size: \".concat(styles.FONTSIZE).concat(/^\\d+$/.test(styles.FONTSIZE) ? 'px' : '', \";\");\n      }\n\n      if (styles.FONTFAMILY) {\n        styleString += \"font-family: \".concat(styles.FONTFAMILY, \";\");\n      }\n\n      styleString += '\"';\n      return \"<span \".concat(styleString, \">\").concat(text, \"</span>\");\n    }\n\n    return text;\n  }\n  /**\n  * Function will return markup for Entity.\n  */\n\n\n  function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n    var entity = entityMap[entityKey];\n\n    if (typeof customEntityTransform === 'function') {\n      var html = customEntityTransform(entity, text);\n\n      if (html) {\n        return html;\n      }\n    }\n\n    if (entity.type === 'MENTION') {\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" class=\\\"wysiwyg-mention\\\" data-mention data-value=\\\"\").concat(entity.data.value, \"\\\">\").concat(text, \"</a>\");\n    }\n\n    if (entity.type === 'LINK') {\n      var targetOption = entity.data.targetOption || '_self';\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" target=\\\"\").concat(targetOption, \"\\\">\").concat(text, \"</a>\");\n    }\n\n    if (entity.type === 'IMAGE') {\n      var alignment = entity.data.alignment;\n\n      if (alignment && alignment.length) {\n        return \"<div style=\\\"text-align:\".concat(alignment, \";\\\"><img src=\\\"\").concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/></div>\");\n      }\n\n      return \"<img src=\\\"\".concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/>\");\n    }\n\n    if (entity.type === 'EMBEDDED_LINK') {\n      return \"<iframe width=\\\"\".concat(entity.data.width, \"\\\" height=\\\"\").concat(entity.data.height, \"\\\" src=\\\"\").concat(entity.data.src, \"\\\" frameBorder=\\\"0\\\"></iframe>\");\n    }\n\n    return text;\n  }\n  /**\n  * For a given section in a block the function will return a further list of sections,\n  * with similar inline styles applicable to them.\n  */\n\n\n  function getInlineStyleSections(block, styles, start, end) {\n    var styleSections = [];\n    var text = Array.from(block.text);\n\n    if (text.length > 0) {\n      var inlineStyles = getStyleArrayForBlock(block);\n      var section;\n\n      for (var i = start; i < end; i += 1) {\n        if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n          section.text.push(text[i]);\n          section.end = i + 1;\n        } else {\n          section = {\n            styles: getStylesAtOffset(inlineStyles, i),\n            text: [text[i]],\n            start: i,\n            end: i + 1\n          };\n          styleSections.push(section);\n        }\n      }\n    }\n\n    return styleSections;\n  }\n  /**\n  * Replace leading blank spaces by &nbsp;\n  */\n\n\n  function trimLeadingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = 0; i < replacedText.length; i += 1) {\n        if (sectionText[i] === ' ') {\n          replacedText = replacedText.replace(' ', '&nbsp;');\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * Replace trailing blank spaces by &nbsp;\n  */\n\n\n  function trimTrailingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n        if (replacedText[i] === ' ') {\n          replacedText = \"\".concat(replacedText.substring(0, i), \"&nbsp;\").concat(replacedText.substring(i + 1));\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  * like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n  */\n\n\n  function getStyleTagSectionMarkup(styleSection) {\n    var styles = styleSection.styles,\n        text = styleSection.text;\n    var content = getSectionText(text);\n    forEach(styles, function (style, value) {\n      content = addInlineStyleMarkup(style, content);\n    });\n    return content;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  like color, background-color, font-size are applicable.\n  */\n\n\n  function getInlineStyleSectionMarkup(block, styleSection) {\n    var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);\n    var styleSectionText = '';\n    styleTagSections.forEach(function (stylePropertySection) {\n      styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n    });\n    styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n    return styleSectionText;\n  }\n  /*\n  * The method returns markup for an entity section.\n  * An entity section is a continuous section in a block\n  * to which same entity or no entity is applicable.\n  */\n\n\n  function getSectionMarkup(block, entityMap, section, customEntityTransform) {\n    var entityInlineMarkup = [];\n    var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);\n    inlineStyleSections.forEach(function (styleSection) {\n      entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n    });\n    var sectionText = entityInlineMarkup.join('');\n\n    if (section.type === 'ENTITY') {\n      if (section.entityKey !== undefined && section.entityKey !== null) {\n        sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n      }\n    } else if (section.type === 'HASHTAG') {\n      sectionText = \"<a href=\\\"\".concat(sectionText, \"\\\" class=\\\"wysiwyg-hashtag\\\">\").concat(sectionText, \"</a>\");\n    }\n\n    return sectionText;\n  }\n  /**\n  * Function will return the markup for block preserving the inline styles and\n  * special characters like newlines or blank spaces.\n  */\n\n\n  function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n    var blockMarkup = [];\n    var sections = getSections(block, hashtagConfig);\n    sections.forEach(function (section, index) {\n      var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n\n      if (index === 0) {\n        sectionText = trimLeadingZeros(sectionText);\n      }\n\n      if (index === sections.length - 1) {\n        sectionText = trimTrailingZeros(sectionText);\n      }\n\n      blockMarkup.push(sectionText);\n    });\n    return blockMarkup.join('');\n  }\n  /**\n  * Function will return html for the block.\n  */\n\n\n  function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var blockHtml = [];\n\n    if (isAtomicEntityBlock(block)) {\n      blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n    } else {\n      var blockTag = getBlockTag(block.type);\n\n      if (blockTag) {\n        blockHtml.push(\"<\".concat(blockTag));\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          blockHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n\n        if (directional) {\n          blockHtml.push(' dir = \"auto\"');\n        }\n\n        blockHtml.push('>');\n        blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        blockHtml.push(\"</\".concat(blockTag, \">\"));\n      }\n    }\n\n    blockHtml.push('\\n');\n    return blockHtml.join('');\n  }\n  /**\n  * Function to check if a block is of type list.\n  */\n\n\n  function isList(blockType) {\n    return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n  }\n  /**\n  * Function will return html markup for a list block.\n  */\n\n\n  function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var listHtml = [];\n    var nestedListBlock = [];\n    var previousBlock;\n    listBlocks.forEach(function (block) {\n      var nestedBlock = false;\n\n      if (!previousBlock) {\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.type !== block.type) {\n        listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.depth === block.depth) {\n        if (nestedListBlock && nestedListBlock.length > 0) {\n          listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n          nestedListBlock = [];\n        }\n      } else {\n        nestedBlock = true;\n        nestedListBlock.push(block);\n      }\n\n      if (!nestedBlock) {\n        listHtml.push('<li');\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          listHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n\n        if (directional) {\n          listHtml.push(' dir = \"auto\"');\n        }\n\n        listHtml.push('>');\n        listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        listHtml.push('</li>\\n');\n        previousBlock = block;\n      }\n    });\n\n    if (nestedListBlock && nestedListBlock.length > 0) {\n      listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n    }\n\n    listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n    return listHtml.join('');\n  }\n  /**\n  * The function will generate html markup for given draftjs editorContent.\n  */\n\n\n  function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n    var html = [];\n\n    if (editorContent) {\n      var blocks = editorContent.blocks,\n          entityMap = editorContent.entityMap;\n\n      if (blocks && blocks.length > 0) {\n        var listBlocks = [];\n        blocks.forEach(function (block) {\n          if (isList(block.type)) {\n            listBlocks.push(block);\n          } else {\n            if (listBlocks.length > 0) {\n              var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n\n              html.push(listHtml);\n              listBlocks = [];\n            }\n\n            var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n            html.push(blockHtml);\n          }\n        });\n\n        if (listBlocks.length > 0) {\n          var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n\n          html.push(listHtml);\n          listBlocks = [];\n        }\n      }\n    }\n\n    return html.join('');\n  }\n\n  return draftToHtml;\n});","map":{"version":3,"sources":["D:/workspace/flying-assess/flyingcarpet-shared-inbox/node_modules/draftjs-to-html/lib/draftjs-to-html.js"],"names":["global","factory","exports","module","define","amd","self","draftjsToHtml","forEach","obj","callback","key","hasOwnProperty","call","isEmptyString","str","undefined","length","trim","blockTypesMapping","unstyled","blockquote","code","getBlockTag","type","getBlockStyle","data","styles","value","concat","getHashtagRanges","blockText","hashtagConfig","sections","counter","startIndex","text","trigger","separator","substr","indexOf","endIndex","hashtag","push","offset","getSections","block","lastOffset","sectionRanges","entityRanges","map","range","sort","s1","s2","r","start","end","entityKey","isAtomicEntityBlock","getStyleArrayForBlock","inlineStyleRanges","inlineStyles","BOLD","Array","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT","COLOR","BGCOLOR","FONTSIZE","FONTFAMILY","i","style","substring","getStylesAtOffset","sameStyleAsPrevious","index","sameStyled","addInlineStyleMarkup","content","getSectionText","chars","ch","join","addStylePropertyMarkup","styleString","test","getEntityMarkup","entityMap","customEntityTransform","entity","html","url","targetOption","alignment","src","alt","height","width","getInlineStyleSections","styleSections","from","section","trimLeadingZeros","sectionText","replacedText","replace","trimTrailingZeros","getStyleTagSectionMarkup","styleSection","getInlineStyleSectionMarkup","styleTagSections","styleSectionText","stylePropertySection","getSectionMarkup","entityInlineMarkup","inlineStyleSections","getBlockInnerMarkup","blockMarkup","getBlockMarkup","directional","blockHtml","blockTag","blockStyle","isList","blockType","getListMarkup","listBlocks","listHtml","nestedListBlock","previousBlock","nestedBlock","depth","draftToHtml","editorContent","blocks"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.draftjsToHtml = factory());\n}(this, (function () { 'use strict';\n\n  /**\n  * Utility function to execute callback for eack key->value pair.\n  */\n  function forEach(obj, callback) {\n    if (obj) {\n      for (var key in obj) {\n        // eslint-disable-line no-restricted-syntax\n        if ({}.hasOwnProperty.call(obj, key)) {\n          callback(key, obj[key]);\n        }\n      }\n    }\n  }\n  /**\n  * The function returns true if the string passed to it has no content.\n  */\n\n  function isEmptyString(str) {\n    if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n  * Mapping block-type to corresponding html tag.\n  */\n\n  var blockTypesMapping = {\n    unstyled: 'p',\n    'header-one': 'h1',\n    'header-two': 'h2',\n    'header-three': 'h3',\n    'header-four': 'h4',\n    'header-five': 'h5',\n    'header-six': 'h6',\n    'unordered-list-item': 'ul',\n    'ordered-list-item': 'ol',\n    blockquote: 'blockquote',\n    code: 'pre'\n  };\n  /**\n  * Function will return HTML tag for a block.\n  */\n\n  function getBlockTag(type) {\n    return type && blockTypesMapping[type];\n  }\n  /**\n  * Function will return style string for a block.\n  */\n\n  function getBlockStyle(data) {\n    var styles = '';\n    forEach(data, function (key, value) {\n      if (value) {\n        styles += \"\".concat(key, \":\").concat(value, \";\");\n      }\n    });\n    return styles;\n  }\n  /**\n  * The function returns an array of hashtag-sections in blocks.\n  * These will be areas in block which have hashtags applicable to them.\n  */\n\n  function getHashtagRanges(blockText, hashtagConfig) {\n    var sections = [];\n\n    if (hashtagConfig) {\n      var counter = 0;\n      var startIndex = 0;\n      var text = blockText;\n      var trigger = hashtagConfig.trigger || '#';\n      var separator = hashtagConfig.separator || ' ';\n\n      for (; text.length > 0 && startIndex >= 0;) {\n        if (text[0] === trigger) {\n          startIndex = 0;\n          counter = 0;\n          text = text.substr(trigger.length);\n        } else {\n          startIndex = text.indexOf(separator + trigger);\n\n          if (startIndex >= 0) {\n            text = text.substr(startIndex + (separator + trigger).length);\n            counter += startIndex + separator.length;\n          }\n        }\n\n        if (startIndex >= 0) {\n          var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n          var hashtag = text.substr(0, endIndex);\n\n          if (hashtag && hashtag.length > 0) {\n            sections.push({\n              offset: counter,\n              length: hashtag.length + trigger.length,\n              type: 'HASHTAG'\n            });\n          }\n\n          counter += trigger.length;\n        }\n      }\n    }\n\n    return sections;\n  }\n  /**\n  * The function returns an array of entity-sections in blocks.\n  * These will be areas in block which have same entity or no entity applicable to them.\n  */\n\n\n  function getSections(block, hashtagConfig) {\n    var sections = [];\n    var lastOffset = 0;\n    var sectionRanges = block.entityRanges.map(function (range) {\n      var offset = range.offset,\n          length = range.length,\n          key = range.key;\n      return {\n        offset: offset,\n        length: length,\n        key: key,\n        type: 'ENTITY'\n      };\n    });\n    sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n    sectionRanges = sectionRanges.sort(function (s1, s2) {\n      return s1.offset - s2.offset;\n    });\n    sectionRanges.forEach(function (r) {\n      if (r.offset > lastOffset) {\n        sections.push({\n          start: lastOffset,\n          end: r.offset\n        });\n      }\n\n      sections.push({\n        start: r.offset,\n        end: r.offset + r.length,\n        entityKey: r.key,\n        type: r.type\n      });\n      lastOffset = r.offset + r.length;\n    });\n\n    if (lastOffset < block.text.length) {\n      sections.push({\n        start: lastOffset,\n        end: block.text.length\n      });\n    }\n\n    return sections;\n  }\n  /**\n  * Function to check if the block is an atomic entity block.\n  */\n\n\n  function isAtomicEntityBlock(block) {\n    if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  * The function will return array of inline styles applicable to the block.\n  */\n\n\n  function getStyleArrayForBlock(block) {\n    var text = block.text,\n        inlineStyleRanges = block.inlineStyleRanges;\n    var inlineStyles = {\n      BOLD: new Array(text.length),\n      ITALIC: new Array(text.length),\n      UNDERLINE: new Array(text.length),\n      STRIKETHROUGH: new Array(text.length),\n      CODE: new Array(text.length),\n      SUPERSCRIPT: new Array(text.length),\n      SUBSCRIPT: new Array(text.length),\n      COLOR: new Array(text.length),\n      BGCOLOR: new Array(text.length),\n      FONTSIZE: new Array(text.length),\n      FONTFAMILY: new Array(text.length),\n      length: text.length\n    };\n\n    if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n      inlineStyleRanges.forEach(function (range) {\n        var offset = range.offset;\n        var length = offset + range.length;\n\n        for (var i = offset; i < length; i += 1) {\n          if (range.style.indexOf('color-') === 0) {\n            inlineStyles.COLOR[i] = range.style.substring(6);\n          } else if (range.style.indexOf('bgcolor-') === 0) {\n            inlineStyles.BGCOLOR[i] = range.style.substring(8);\n          } else if (range.style.indexOf('fontsize-') === 0) {\n            inlineStyles.FONTSIZE[i] = range.style.substring(9);\n          } else if (range.style.indexOf('fontfamily-') === 0) {\n            inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n          } else if (inlineStyles[range.style]) {\n            inlineStyles[range.style][i] = true;\n          }\n        }\n      });\n    }\n\n    return inlineStyles;\n  }\n  /**\n  * The function will return inline style applicable at some offset within a block.\n  */\n\n\n  function getStylesAtOffset(inlineStyles, offset) {\n    var styles = {};\n\n    if (inlineStyles.COLOR[offset]) {\n      styles.COLOR = inlineStyles.COLOR[offset];\n    }\n\n    if (inlineStyles.BGCOLOR[offset]) {\n      styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n    }\n\n    if (inlineStyles.FONTSIZE[offset]) {\n      styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n    }\n\n    if (inlineStyles.FONTFAMILY[offset]) {\n      styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n    }\n\n    if (inlineStyles.UNDERLINE[offset]) {\n      styles.UNDERLINE = true;\n    }\n\n    if (inlineStyles.ITALIC[offset]) {\n      styles.ITALIC = true;\n    }\n\n    if (inlineStyles.BOLD[offset]) {\n      styles.BOLD = true;\n    }\n\n    if (inlineStyles.STRIKETHROUGH[offset]) {\n      styles.STRIKETHROUGH = true;\n    }\n\n    if (inlineStyles.CODE[offset]) {\n      styles.CODE = true;\n    }\n\n    if (inlineStyles.SUBSCRIPT[offset]) {\n      styles.SUBSCRIPT = true;\n    }\n\n    if (inlineStyles.SUPERSCRIPT[offset]) {\n      styles.SUPERSCRIPT = true;\n    }\n\n    return styles;\n  }\n  /**\n  * Function returns true for a set of styles if the value of these styles at an offset\n  * are same as that on the previous offset.\n  */\n\n  function sameStyleAsPrevious(inlineStyles, styles, index) {\n    var sameStyled = true;\n\n    if (index > 0 && index < inlineStyles.length) {\n      styles.forEach(function (style) {\n        sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n      });\n    } else {\n      sameStyled = false;\n    }\n\n    return sameStyled;\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n  function addInlineStyleMarkup(style, content) {\n    if (style === 'BOLD') {\n      return \"<strong>\".concat(content, \"</strong>\");\n    }\n\n    if (style === 'ITALIC') {\n      return \"<em>\".concat(content, \"</em>\");\n    }\n\n    if (style === 'UNDERLINE') {\n      return \"<ins>\".concat(content, \"</ins>\");\n    }\n\n    if (style === 'STRIKETHROUGH') {\n      return \"<del>\".concat(content, \"</del>\");\n    }\n\n    if (style === 'CODE') {\n      return \"<code>\".concat(content, \"</code>\");\n    }\n\n    if (style === 'SUPERSCRIPT') {\n      return \"<sup>\".concat(content, \"</sup>\");\n    }\n\n    if (style === 'SUBSCRIPT') {\n      return \"<sub>\".concat(content, \"</sub>\");\n    }\n\n    return content;\n  }\n  /**\n  * The function returns text for given section of block after doing required character replacements.\n  */\n\n  function getSectionText(text) {\n    if (text && text.length > 0) {\n      var chars = text.map(function (ch) {\n        switch (ch) {\n          case '\\n':\n            return '<br>';\n\n          case '&':\n            return '&amp;';\n\n          case '<':\n            return '&lt;';\n\n          case '>':\n            return '&gt;';\n\n          default:\n            return ch;\n        }\n      });\n      return chars.join('');\n    }\n\n    return '';\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n\n  function addStylePropertyMarkup(styles, text) {\n    if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n      var styleString = 'style=\"';\n\n      if (styles.COLOR) {\n        styleString += \"color: \".concat(styles.COLOR, \";\");\n      }\n\n      if (styles.BGCOLOR) {\n        styleString += \"background-color: \".concat(styles.BGCOLOR, \";\");\n      }\n\n      if (styles.FONTSIZE) {\n        styleString += \"font-size: \".concat(styles.FONTSIZE).concat(/^\\d+$/.test(styles.FONTSIZE) ? 'px' : '', \";\");\n      }\n\n      if (styles.FONTFAMILY) {\n        styleString += \"font-family: \".concat(styles.FONTFAMILY, \";\");\n      }\n\n      styleString += '\"';\n      return \"<span \".concat(styleString, \">\").concat(text, \"</span>\");\n    }\n\n    return text;\n  }\n  /**\n  * Function will return markup for Entity.\n  */\n\n  function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n    var entity = entityMap[entityKey];\n\n    if (typeof customEntityTransform === 'function') {\n      var html = customEntityTransform(entity, text);\n\n      if (html) {\n        return html;\n      }\n    }\n\n    if (entity.type === 'MENTION') {\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" class=\\\"wysiwyg-mention\\\" data-mention data-value=\\\"\").concat(entity.data.value, \"\\\">\").concat(text, \"</a>\");\n    }\n\n    if (entity.type === 'LINK') {\n      var targetOption = entity.data.targetOption || '_self';\n      return \"<a href=\\\"\".concat(entity.data.url, \"\\\" target=\\\"\").concat(targetOption, \"\\\">\").concat(text, \"</a>\");\n    }\n\n    if (entity.type === 'IMAGE') {\n      var alignment = entity.data.alignment;\n\n      if (alignment && alignment.length) {\n        return \"<div style=\\\"text-align:\".concat(alignment, \";\\\"><img src=\\\"\").concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/></div>\");\n      }\n\n      return \"<img src=\\\"\".concat(entity.data.src, \"\\\" alt=\\\"\").concat(entity.data.alt, \"\\\" style=\\\"height: \").concat(entity.data.height, \";width: \").concat(entity.data.width, \"\\\"/>\");\n    }\n\n    if (entity.type === 'EMBEDDED_LINK') {\n      return \"<iframe width=\\\"\".concat(entity.data.width, \"\\\" height=\\\"\").concat(entity.data.height, \"\\\" src=\\\"\").concat(entity.data.src, \"\\\" frameBorder=\\\"0\\\"></iframe>\");\n    }\n\n    return text;\n  }\n  /**\n  * For a given section in a block the function will return a further list of sections,\n  * with similar inline styles applicable to them.\n  */\n\n\n  function getInlineStyleSections(block, styles, start, end) {\n    var styleSections = [];\n    var text = Array.from(block.text);\n\n    if (text.length > 0) {\n      var inlineStyles = getStyleArrayForBlock(block);\n      var section;\n\n      for (var i = start; i < end; i += 1) {\n        if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n          section.text.push(text[i]);\n          section.end = i + 1;\n        } else {\n          section = {\n            styles: getStylesAtOffset(inlineStyles, i),\n            text: [text[i]],\n            start: i,\n            end: i + 1\n          };\n          styleSections.push(section);\n        }\n      }\n    }\n\n    return styleSections;\n  }\n  /**\n  * Replace leading blank spaces by &nbsp;\n  */\n\n\n  function trimLeadingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = 0; i < replacedText.length; i += 1) {\n        if (sectionText[i] === ' ') {\n          replacedText = replacedText.replace(' ', '&nbsp;');\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * Replace trailing blank spaces by &nbsp;\n  */\n\n  function trimTrailingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n        if (replacedText[i] === ' ') {\n          replacedText = \"\".concat(replacedText.substring(0, i), \"&nbsp;\").concat(replacedText.substring(i + 1));\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  * like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n  */\n\n  function getStyleTagSectionMarkup(styleSection) {\n    var styles = styleSection.styles,\n        text = styleSection.text;\n    var content = getSectionText(text);\n    forEach(styles, function (style, value) {\n      content = addInlineStyleMarkup(style, content);\n    });\n    return content;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  like color, background-color, font-size are applicable.\n  */\n\n\n  function getInlineStyleSectionMarkup(block, styleSection) {\n    var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);\n    var styleSectionText = '';\n    styleTagSections.forEach(function (stylePropertySection) {\n      styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n    });\n    styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n    return styleSectionText;\n  }\n  /*\n  * The method returns markup for an entity section.\n  * An entity section is a continuous section in a block\n  * to which same entity or no entity is applicable.\n  */\n\n\n  function getSectionMarkup(block, entityMap, section, customEntityTransform) {\n    var entityInlineMarkup = [];\n    var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);\n    inlineStyleSections.forEach(function (styleSection) {\n      entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n    });\n    var sectionText = entityInlineMarkup.join('');\n\n    if (section.type === 'ENTITY') {\n      if (section.entityKey !== undefined && section.entityKey !== null) {\n        sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n      }\n    } else if (section.type === 'HASHTAG') {\n      sectionText = \"<a href=\\\"\".concat(sectionText, \"\\\" class=\\\"wysiwyg-hashtag\\\">\").concat(sectionText, \"</a>\");\n    }\n\n    return sectionText;\n  }\n  /**\n  * Function will return the markup for block preserving the inline styles and\n  * special characters like newlines or blank spaces.\n  */\n\n\n  function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n    var blockMarkup = [];\n    var sections = getSections(block, hashtagConfig);\n    sections.forEach(function (section, index) {\n      var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n\n      if (index === 0) {\n        sectionText = trimLeadingZeros(sectionText);\n      }\n\n      if (index === sections.length - 1) {\n        sectionText = trimTrailingZeros(sectionText);\n      }\n\n      blockMarkup.push(sectionText);\n    });\n    return blockMarkup.join('');\n  }\n  /**\n  * Function will return html for the block.\n  */\n\n  function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var blockHtml = [];\n\n    if (isAtomicEntityBlock(block)) {\n      blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n    } else {\n      var blockTag = getBlockTag(block.type);\n\n      if (blockTag) {\n        blockHtml.push(\"<\".concat(blockTag));\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          blockHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n\n        if (directional) {\n          blockHtml.push(' dir = \"auto\"');\n        }\n\n        blockHtml.push('>');\n        blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        blockHtml.push(\"</\".concat(blockTag, \">\"));\n      }\n    }\n\n    blockHtml.push('\\n');\n    return blockHtml.join('');\n  }\n\n  /**\n  * Function to check if a block is of type list.\n  */\n\n  function isList(blockType) {\n    return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n  }\n  /**\n  * Function will return html markup for a list block.\n  */\n\n  function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var listHtml = [];\n    var nestedListBlock = [];\n    var previousBlock;\n    listBlocks.forEach(function (block) {\n      var nestedBlock = false;\n\n      if (!previousBlock) {\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.type !== block.type) {\n        listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n        listHtml.push(\"<\".concat(getBlockTag(block.type), \">\\n\"));\n      } else if (previousBlock.depth === block.depth) {\n        if (nestedListBlock && nestedListBlock.length > 0) {\n          listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n          nestedListBlock = [];\n        }\n      } else {\n        nestedBlock = true;\n        nestedListBlock.push(block);\n      }\n\n      if (!nestedBlock) {\n        listHtml.push('<li');\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          listHtml.push(\" style=\\\"\".concat(blockStyle, \"\\\"\"));\n        }\n\n        if (directional) {\n          listHtml.push(' dir = \"auto\"');\n        }\n\n        listHtml.push('>');\n        listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        listHtml.push('</li>\\n');\n        previousBlock = block;\n      }\n    });\n\n    if (nestedListBlock && nestedListBlock.length > 0) {\n      listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n    }\n\n    listHtml.push(\"</\".concat(getBlockTag(previousBlock.type), \">\\n\"));\n    return listHtml.join('');\n  }\n\n  /**\n  * The function will generate html markup for given draftjs editorContent.\n  */\n\n  function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n    var html = [];\n\n    if (editorContent) {\n      var blocks = editorContent.blocks,\n          entityMap = editorContent.entityMap;\n\n      if (blocks && blocks.length > 0) {\n        var listBlocks = [];\n        blocks.forEach(function (block) {\n          if (isList(block.type)) {\n            listBlocks.push(block);\n          } else {\n            if (listBlocks.length > 0) {\n              var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n\n              html.push(listHtml);\n              listBlocks = [];\n            }\n\n            var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n            html.push(blockHtml);\n          }\n        });\n\n        if (listBlocks.length > 0) {\n          var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n\n          html.push(listHtml);\n          listBlocks = [];\n        }\n      }\n    }\n\n    return html.join('');\n  }\n\n  return draftToHtml;\n\n})));\n"]},"metadata":{},"sourceType":"script"}