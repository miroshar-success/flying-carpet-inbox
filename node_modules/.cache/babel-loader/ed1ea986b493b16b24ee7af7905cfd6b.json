{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar DraftEntitySegments = require(\"./DraftEntitySegments\");\n\nvar getRangesForDraftEntity = require(\"./getRangesForDraftEntity\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n/**\n * Given a SelectionState and a removal direction, determine the entire range\n * that should be removed from a ContentState. This is based on any entities\n * within the target, with their `mutability` values taken into account.\n *\n * For instance, if we are attempting to remove part of an \"immutable\" entity\n * range, the entire entity must be removed. The returned `SelectionState`\n * will be adjusted accordingly.\n */\n\n\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var startEntityKey = startBlock.getEntityAt(start);\n  var endEntityKey = endBlock.getEntityAt(end - 1);\n\n  if (!startEntityKey && !endEntityKey) {\n    return selectionState;\n  }\n\n  var newSelectionState = selectionState;\n\n  if (startEntityKey && startEntityKey === endEntityKey) {\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\n  } else if (startEntityKey && endEntityKey) {\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: startSelectionState.getAnchorOffset(),\n      focusOffset: endSelectionState.getFocusOffset(),\n      isBackward: false\n    });\n  } else if (startEntityKey) {\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: _startSelectionState.getStartOffset(),\n      isBackward: false\n    });\n  } else if (endEntityKey) {\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n\n    newSelectionState = newSelectionState.merge({\n      focusOffset: _endSelectionState.getEndOffset(),\n      isBackward: false\n    });\n  }\n\n  return newSelectionState;\n}\n\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n\n  var entity = entityMap.__get(entityKey);\n\n  var mutability = entity.getMutability();\n  var sideToConsider = isEntityAtStart ? start : end; // `MUTABLE` entities can just have the specified range of text removed\n  // directly. No adjustments are needed.\n\n  if (mutability === 'MUTABLE') {\n    return selectionState;\n  } // Find the entity range that overlaps with our removal range.\n\n\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\n    return sideToConsider <= range.end && sideToConsider >= range.start;\n  });\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\n  var entityRange = entityRanges[0]; // For `IMMUTABLE` entity types, we will remove the entire entity range.\n\n  if (mutability === 'IMMUTABLE') {\n    return selectionState.merge({\n      anchorOffset: entityRange.start,\n      focusOffset: entityRange.end,\n      isBackward: false\n    });\n  } // For `SEGMENTED` entity types, determine the appropriate segment to\n  // remove.\n\n\n  if (!isEntireSelectionWithinEntity) {\n    if (isEntityAtStart) {\n      end = entityRange.end;\n    } else {\n      start = entityRange.start;\n    }\n  }\n\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\n  return selectionState.merge({\n    anchorOffset: removalRange.start,\n    focusOffset: removalRange.end,\n    isBackward: false\n  });\n}\n\nmodule.exports = getCharacterRemovalRange;","map":{"version":3,"sources":["D:/workspace/flyingcarpet/flyingcarpet-shared-inbox/node_modules/draft-js/lib/getCharacterRemovalRange.js"],"names":["DraftEntitySegments","require","getRangesForDraftEntity","invariant","getCharacterRemovalRange","entityMap","startBlock","endBlock","selectionState","direction","start","getStartOffset","end","getEndOffset","startEntityKey","getEntityAt","endEntityKey","newSelectionState","getEntityRemovalRange","startSelectionState","endSelectionState","merge","anchorOffset","getAnchorOffset","focusOffset","getFocusOffset","isBackward","_startSelectionState","_endSelectionState","block","entityKey","isEntireSelectionWithinEntity","isEntityAtStart","entity","__get","mutability","getMutability","sideToConsider","entityRanges","filter","range","length","process","env","NODE_ENV","entityRange","removalRange","getRemovalRange","getText","slice","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar DraftEntitySegments = require(\"./DraftEntitySegments\");\n\nvar getRangesForDraftEntity = require(\"./getRangesForDraftEntity\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n/**\n * Given a SelectionState and a removal direction, determine the entire range\n * that should be removed from a ContentState. This is based on any entities\n * within the target, with their `mutability` values taken into account.\n *\n * For instance, if we are attempting to remove part of an \"immutable\" entity\n * range, the entire entity must be removed. The returned `SelectionState`\n * will be adjusted accordingly.\n */\n\n\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var startEntityKey = startBlock.getEntityAt(start);\n  var endEntityKey = endBlock.getEntityAt(end - 1);\n\n  if (!startEntityKey && !endEntityKey) {\n    return selectionState;\n  }\n\n  var newSelectionState = selectionState;\n\n  if (startEntityKey && startEntityKey === endEntityKey) {\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\n  } else if (startEntityKey && endEntityKey) {\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: startSelectionState.getAnchorOffset(),\n      focusOffset: endSelectionState.getFocusOffset(),\n      isBackward: false\n    });\n  } else if (startEntityKey) {\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: _startSelectionState.getStartOffset(),\n      isBackward: false\n    });\n  } else if (endEntityKey) {\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n\n    newSelectionState = newSelectionState.merge({\n      focusOffset: _endSelectionState.getEndOffset(),\n      isBackward: false\n    });\n  }\n\n  return newSelectionState;\n}\n\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n\n  var entity = entityMap.__get(entityKey);\n\n  var mutability = entity.getMutability();\n  var sideToConsider = isEntityAtStart ? start : end; // `MUTABLE` entities can just have the specified range of text removed\n  // directly. No adjustments are needed.\n\n  if (mutability === 'MUTABLE') {\n    return selectionState;\n  } // Find the entity range that overlaps with our removal range.\n\n\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\n    return sideToConsider <= range.end && sideToConsider >= range.start;\n  });\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\n  var entityRange = entityRanges[0]; // For `IMMUTABLE` entity types, we will remove the entire entity range.\n\n  if (mutability === 'IMMUTABLE') {\n    return selectionState.merge({\n      anchorOffset: entityRange.start,\n      focusOffset: entityRange.end,\n      isBackward: false\n    });\n  } // For `SEGMENTED` entity types, determine the appropriate segment to\n  // remove.\n\n\n  if (!isEntireSelectionWithinEntity) {\n    if (isEntityAtStart) {\n      end = entityRange.end;\n    } else {\n      start = entityRange.start;\n    }\n  }\n\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\n  return selectionState.merge({\n    anchorOffset: removalRange.start,\n    focusOffset: removalRange.end,\n    isBackward: false\n  });\n}\n\nmodule.exports = getCharacterRemovalRange;"]},"metadata":{},"sourceType":"script"}