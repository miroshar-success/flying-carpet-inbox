{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar BlockMapBuilder = require(\"./BlockMapBuilder\");\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar Immutable = require(\"immutable\");\n\nvar insertIntoList = require(\"./insertIntoList\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar randomizeBlockMapKeys = require(\"./randomizeBlockMapKeys\");\n\nvar List = Immutable.List;\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var mergeBlockData = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'REPLACE_WITH_NEW_DATA';\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n  var data = null;\n\n  switch (mergeBlockData) {\n    case 'MERGE_OLD_DATA_TO_NEW_DATA':\n      data = fragmentBlock.getData().merge(targetBlock.getData());\n      break;\n\n    case 'REPLACE_WITH_NEW_DATA':\n      data = fragmentBlock.getData();\n      break;\n  }\n\n  var type = targetBlock.getType();\n\n  if (text && type === 'unstyled') {\n    type = fragmentBlock.getType();\n  }\n\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    type: type,\n    data: data\n  });\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\n\n\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\n\n\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = []; // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    } // update the last root block fragment\n\n\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey); // update the original target next block\n\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    } // update fragment parent links\n\n\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    }); // update targetBlock parent child links\n\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray(); // insert fragment children\n\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    } // Insert fragment blocks after the head and before the tail.\n\n\n    fragment // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    }); // update tail\n\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  var mergeBlockData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'REPLACE_WITH_NEW_DATA';\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  } // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n\n\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset, mergeBlockData);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;","map":{"version":3,"sources":["D:/workspace/flying-assess/flyingcarpet-shared-inbox/node_modules/draft-js/lib/insertFragmentIntoContentState.js"],"names":["BlockMapBuilder","require","ContentBlockNode","Immutable","insertIntoList","invariant","randomizeBlockMapKeys","List","updateExistingBlock","contentState","selectionState","blockMap","fragmentBlock","targetKey","targetOffset","mergeBlockData","arguments","length","undefined","targetBlock","get","text","getText","chars","getCharacterList","finalKey","finalOffset","data","getData","merge","type","getType","newBlock","slice","characterList","set","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","updateHead","block","fragment","headText","headCharacters","appendToHead","first","concat","updateTail","blockSize","tailText","tailCharacters","prependToTail","last","getRootBlocks","headKey","getKey","rootBlock","rootBlocks","push","getNextSiblingKey","lastSiblingKey","updateBlockMapLinks","originalBlockMap","fragmentHeadBlock","withMutations","blockMapState","targetNextKey","targetParentKey","getParentKey","fragmentRootBlocks","lastRootFragmentBlockKey","setIn","forEach","blockKey","targetParent","originalTargetParentChildKeys","getChildKeys","targetBlockIndex","indexOf","insertionIndex","newChildrenKeysArray","toArray","splice","apply","insertFragment","isTreeBasedBlockMap","newBlockArr","fragmentSize","size","target","head","tail","getLength","shouldNotUpdateFromFragmentBlock","isEmpty","updatedBlockMap","createFromArray","insertFragmentIntoContentState","fragmentBlockMap","isCollapsed","process","env","NODE_ENV","getBlockMap","getStartKey","getStartOffset","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar BlockMapBuilder = require(\"./BlockMapBuilder\");\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar Immutable = require(\"immutable\");\n\nvar insertIntoList = require(\"./insertIntoList\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar randomizeBlockMapKeys = require(\"./randomizeBlockMapKeys\");\n\nvar List = Immutable.List;\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var mergeBlockData = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'REPLACE_WITH_NEW_DATA';\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n  var data = null;\n\n  switch (mergeBlockData) {\n    case 'MERGE_OLD_DATA_TO_NEW_DATA':\n      data = fragmentBlock.getData().merge(targetBlock.getData());\n      break;\n\n    case 'REPLACE_WITH_NEW_DATA':\n      data = fragmentBlock.getData();\n      break;\n  }\n\n  var type = targetBlock.getType();\n\n  if (text && type === 'unstyled') {\n    type = fragmentBlock.getType();\n  }\n\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    type: type,\n    data: data\n  });\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\n\n\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\n\n\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = []; // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    } // update the last root block fragment\n\n\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey); // update the original target next block\n\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    } // update fragment parent links\n\n\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    }); // update targetBlock parent child links\n\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray(); // insert fragment children\n\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    } // Insert fragment blocks after the head and before the tail.\n\n\n    fragment // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    }); // update tail\n\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  var mergeBlockData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'REPLACE_WITH_NEW_DATA';\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  } // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n\n\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset, mergeBlockData);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;"]},"metadata":{},"sourceType":"script"}