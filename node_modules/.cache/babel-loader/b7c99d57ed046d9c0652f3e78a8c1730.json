{"ast":null,"code":"import invariant from 'invariant';\nimport stripDiacritics from './stripDiacritics';\nvar CASE_INSENSITIVE = 'i';\nvar COMBINING_MARKS = /[\\u0300-\\u036F]/; // Export for testing.\n\nexport function escapeStringRegexp(str) {\n  !(typeof str === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`escapeStringRegexp` expected a string.') : invariant(false) : void 0; // Escape characters with special meaning either inside or outside character\n  // sets. Use a simple backslash escape when it’s always valid, and a \\unnnn\n  // escape when the simpler form would be disallowed by Unicode patterns’\n  // stricter grammar.\n\n  return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}\nexport default function getMatchBounds(subject, str) {\n  var search = new RegExp(escapeStringRegexp(stripDiacritics(str)), CASE_INSENSITIVE);\n  var matches = search.exec(stripDiacritics(subject));\n\n  if (!matches) {\n    return null;\n  }\n\n  var start = matches.index;\n  var matchLength = matches[0].length; // Account for combining marks, which changes the indices.\n\n  if (COMBINING_MARKS.test(subject)) {\n    // Starting at the beginning of the subject string, check for the number of\n    // combining marks and increment the start index whenever one is found.\n    for (var ii = 0; ii <= start; ii++) {\n      if (COMBINING_MARKS.test(subject[ii])) {\n        start += 1;\n      }\n    } // Similarly, increment the length of the match string if it contains a\n    // combining mark.\n\n\n    for (var _ii = start; _ii <= start + matchLength; _ii++) {\n      if (COMBINING_MARKS.test(subject[_ii])) {\n        matchLength += 1;\n      }\n    }\n  }\n\n  return {\n    end: start + matchLength,\n    start: start\n  };\n}","map":{"version":3,"sources":["D:/workspace/flyingcarpet/flyingcarpet-shared-inbox/node_modules/react-bootstrap-typeahead/es/utils/getMatchBounds.js"],"names":["invariant","stripDiacritics","CASE_INSENSITIVE","COMBINING_MARKS","escapeStringRegexp","str","process","env","NODE_ENV","replace","getMatchBounds","subject","search","RegExp","matches","exec","start","index","matchLength","length","test","ii","_ii","end"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,WAAtB;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,IAAIC,gBAAgB,GAAG,GAAvB;AACA,IAAIC,eAAe,GAAG,iBAAtB,C,CACA;;AACA,OAAO,SAASC,kBAAT,CAA4BC,GAA5B,EAAiC;AACtC,IAAE,OAAOA,GAAP,KAAe,QAAjB,IAA6BC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCR,SAAS,CAAC,KAAD,EAAQ,yCAAR,CAAjD,GAAsGA,SAAS,CAAC,KAAD,CAA5I,GAAsJ,KAAK,CAA3J,CADsC,CACwH;AAC9J;AACA;AACA;;AAEA,SAAOK,GAAG,CAACI,OAAJ,CAAY,qBAAZ,EAAmC,MAAnC,EAA2CA,OAA3C,CAAmD,IAAnD,EAAyD,OAAzD,CAAP;AACD;AACD,eAAe,SAASC,cAAT,CAAwBC,OAAxB,EAAiCN,GAAjC,EAAsC;AACnD,MAAIO,MAAM,GAAG,IAAIC,MAAJ,CAAWT,kBAAkB,CAACH,eAAe,CAACI,GAAD,CAAhB,CAA7B,EAAqDH,gBAArD,CAAb;AACA,MAAIY,OAAO,GAAGF,MAAM,CAACG,IAAP,CAAYd,eAAe,CAACU,OAAD,CAA3B,CAAd;;AAEA,MAAI,CAACG,OAAL,EAAc;AACZ,WAAO,IAAP;AACD;;AAED,MAAIE,KAAK,GAAGF,OAAO,CAACG,KAApB;AACA,MAAIC,WAAW,GAAGJ,OAAO,CAAC,CAAD,CAAP,CAAWK,MAA7B,CATmD,CASd;;AAErC,MAAIhB,eAAe,CAACiB,IAAhB,CAAqBT,OAArB,CAAJ,EAAmC;AACjC;AACA;AACA,SAAK,IAAIU,EAAE,GAAG,CAAd,EAAiBA,EAAE,IAAIL,KAAvB,EAA8BK,EAAE,EAAhC,EAAoC;AAClC,UAAIlB,eAAe,CAACiB,IAAhB,CAAqBT,OAAO,CAACU,EAAD,CAA5B,CAAJ,EAAuC;AACrCL,QAAAA,KAAK,IAAI,CAAT;AACD;AACF,KAPgC,CAO/B;AACF;;;AAGA,SAAK,IAAIM,GAAG,GAAGN,KAAf,EAAsBM,GAAG,IAAIN,KAAK,GAAGE,WAArC,EAAkDI,GAAG,EAArD,EAAyD;AACvD,UAAInB,eAAe,CAACiB,IAAhB,CAAqBT,OAAO,CAACW,GAAD,CAA5B,CAAJ,EAAwC;AACtCJ,QAAAA,WAAW,IAAI,CAAf;AACD;AACF;AACF;;AAED,SAAO;AACLK,IAAAA,GAAG,EAAEP,KAAK,GAAGE,WADR;AAELF,IAAAA,KAAK,EAAEA;AAFF,GAAP;AAID","sourcesContent":["import invariant from 'invariant';\nimport stripDiacritics from './stripDiacritics';\nvar CASE_INSENSITIVE = 'i';\nvar COMBINING_MARKS = /[\\u0300-\\u036F]/;\n// Export for testing.\nexport function escapeStringRegexp(str) {\n  !(typeof str === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, '`escapeStringRegexp` expected a string.') : invariant(false) : void 0; // Escape characters with special meaning either inside or outside character\n  // sets. Use a simple backslash escape when it’s always valid, and a \\unnnn\n  // escape when the simpler form would be disallowed by Unicode patterns’\n  // stricter grammar.\n\n  return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n}\nexport default function getMatchBounds(subject, str) {\n  var search = new RegExp(escapeStringRegexp(stripDiacritics(str)), CASE_INSENSITIVE);\n  var matches = search.exec(stripDiacritics(subject));\n\n  if (!matches) {\n    return null;\n  }\n\n  var start = matches.index;\n  var matchLength = matches[0].length; // Account for combining marks, which changes the indices.\n\n  if (COMBINING_MARKS.test(subject)) {\n    // Starting at the beginning of the subject string, check for the number of\n    // combining marks and increment the start index whenever one is found.\n    for (var ii = 0; ii <= start; ii++) {\n      if (COMBINING_MARKS.test(subject[ii])) {\n        start += 1;\n      }\n    } // Similarly, increment the length of the match string if it contains a\n    // combining mark.\n\n\n    for (var _ii = start; _ii <= start + matchLength; _ii++) {\n      if (COMBINING_MARKS.test(subject[_ii])) {\n        matchLength += 1;\n      }\n    }\n  }\n\n  return {\n    end: start + matchLength,\n    start: start\n  };\n}"]},"metadata":{},"sourceType":"module"}