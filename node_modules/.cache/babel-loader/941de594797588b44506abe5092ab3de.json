{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar CharacterMetadata = require(\"./CharacterMetadata\");\n\nvar findRangesImmutable = require(\"./findRangesImmutable\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nfunction removeEntitiesAtEdges(contentState, selectionState) {\n  var blockMap = contentState.getBlockMap();\n  var entityMap = contentState.getEntityMap();\n  var updatedBlocks = {};\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var startBlock = blockMap.get(startKey);\n  var updatedStart = removeForBlock(entityMap, startBlock, startOffset);\n\n  if (updatedStart !== startBlock) {\n    updatedBlocks[startKey] = updatedStart;\n  }\n\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n  var endBlock = blockMap.get(endKey);\n\n  if (startKey === endKey) {\n    endBlock = updatedStart;\n  }\n\n  var updatedEnd = removeForBlock(entityMap, endBlock, endOffset);\n\n  if (updatedEnd !== endBlock) {\n    updatedBlocks[endKey] = updatedEnd;\n  }\n\n  if (!Object.keys(updatedBlocks).length) {\n    return contentState.set('selectionAfter', selectionState);\n  }\n\n  return contentState.merge({\n    blockMap: blockMap.merge(updatedBlocks),\n    selectionAfter: selectionState\n  });\n}\n/**\n * Given a list of characters and an offset that is in the middle of an entity,\n * returns the start and end of the entity that is overlapping the offset.\n * Note: This method requires that the offset be in an entity range.\n */\n\n\nfunction getRemovalRange(characters, entityKey, offset) {\n  var removalRange; // Iterates through a list looking for ranges of matching items\n  // based on the 'isEqual' callback.\n  // Then instead of returning the result, call the 'found' callback\n  // with each range.\n  // Then filters those ranges based on the 'filter' callback\n  //\n  // Here we use it to find ranges of characters with the same entity key.\n\n  findRangesImmutable(characters, // the list to iterate through\n  function (a, b) {\n    return a.getEntity() === b.getEntity();\n  }, // 'isEqual' callback\n  function (element) {\n    return element.getEntity() === entityKey;\n  }, // 'filter' callback\n  function (start, end) {\n    // 'found' callback\n    if (start <= offset && end >= offset) {\n      // this entity overlaps the offset index\n      removalRange = {\n        start: start,\n        end: end\n      };\n    }\n  });\n  !(typeof removalRange === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Removal range must exist within character list.') : invariant(false) : void 0;\n  return removalRange;\n}\n\nfunction removeForBlock(entityMap, block, offset) {\n  var chars = block.getCharacterList();\n  var charBefore = offset > 0 ? chars.get(offset - 1) : undefined;\n  var charAfter = offset < chars.count() ? chars.get(offset) : undefined;\n  var entityBeforeCursor = charBefore ? charBefore.getEntity() : undefined;\n  var entityAfterCursor = charAfter ? charAfter.getEntity() : undefined;\n\n  if (entityAfterCursor && entityAfterCursor === entityBeforeCursor) {\n    var entity = entityMap.__get(entityAfterCursor);\n\n    if (entity.getMutability() !== 'MUTABLE') {\n      var _getRemovalRange = getRemovalRange(chars, entityAfterCursor, offset),\n          start = _getRemovalRange.start,\n          end = _getRemovalRange.end;\n\n      var current;\n\n      while (start < end) {\n        current = chars.get(start);\n        chars = chars.set(start, CharacterMetadata.applyEntity(current, null));\n        start++;\n      }\n\n      return block.set('characterList', chars);\n    }\n  }\n\n  return block;\n}\n\nmodule.exports = removeEntitiesAtEdges;","map":{"version":3,"sources":["D:/workspace/flying-assess/flyingcarpet-shared-inbox/node_modules/draft-js/lib/removeEntitiesAtEdges.js"],"names":["CharacterMetadata","require","findRangesImmutable","invariant","removeEntitiesAtEdges","contentState","selectionState","blockMap","getBlockMap","entityMap","getEntityMap","updatedBlocks","startKey","getStartKey","startOffset","getStartOffset","startBlock","get","updatedStart","removeForBlock","endKey","getEndKey","endOffset","getEndOffset","endBlock","updatedEnd","Object","keys","length","set","merge","selectionAfter","getRemovalRange","characters","entityKey","offset","removalRange","a","b","getEntity","element","start","end","process","env","NODE_ENV","block","chars","getCharacterList","charBefore","undefined","charAfter","count","entityBeforeCursor","entityAfterCursor","entity","__get","getMutability","_getRemovalRange","current","applyEntity","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,iBAAiB,GAAGC,OAAO,CAAC,qBAAD,CAA/B;;AAEA,IAAIC,mBAAmB,GAAGD,OAAO,CAAC,uBAAD,CAAjC;;AAEA,IAAIE,SAAS,GAAGF,OAAO,CAAC,oBAAD,CAAvB;;AAEA,SAASG,qBAAT,CAA+BC,YAA/B,EAA6CC,cAA7C,EAA6D;AAC3D,MAAIC,QAAQ,GAAGF,YAAY,CAACG,WAAb,EAAf;AACA,MAAIC,SAAS,GAAGJ,YAAY,CAACK,YAAb,EAAhB;AACA,MAAIC,aAAa,GAAG,EAApB;AACA,MAAIC,QAAQ,GAAGN,cAAc,CAACO,WAAf,EAAf;AACA,MAAIC,WAAW,GAAGR,cAAc,CAACS,cAAf,EAAlB;AACA,MAAIC,UAAU,GAAGT,QAAQ,CAACU,GAAT,CAAaL,QAAb,CAAjB;AACA,MAAIM,YAAY,GAAGC,cAAc,CAACV,SAAD,EAAYO,UAAZ,EAAwBF,WAAxB,CAAjC;;AAEA,MAAII,YAAY,KAAKF,UAArB,EAAiC;AAC/BL,IAAAA,aAAa,CAACC,QAAD,CAAb,GAA0BM,YAA1B;AACD;;AAED,MAAIE,MAAM,GAAGd,cAAc,CAACe,SAAf,EAAb;AACA,MAAIC,SAAS,GAAGhB,cAAc,CAACiB,YAAf,EAAhB;AACA,MAAIC,QAAQ,GAAGjB,QAAQ,CAACU,GAAT,CAAaG,MAAb,CAAf;;AAEA,MAAIR,QAAQ,KAAKQ,MAAjB,EAAyB;AACvBI,IAAAA,QAAQ,GAAGN,YAAX;AACD;;AAED,MAAIO,UAAU,GAAGN,cAAc,CAACV,SAAD,EAAYe,QAAZ,EAAsBF,SAAtB,CAA/B;;AAEA,MAAIG,UAAU,KAAKD,QAAnB,EAA6B;AAC3Bb,IAAAA,aAAa,CAACS,MAAD,CAAb,GAAwBK,UAAxB;AACD;;AAED,MAAI,CAACC,MAAM,CAACC,IAAP,CAAYhB,aAAZ,EAA2BiB,MAAhC,EAAwC;AACtC,WAAOvB,YAAY,CAACwB,GAAb,CAAiB,gBAAjB,EAAmCvB,cAAnC,CAAP;AACD;;AAED,SAAOD,YAAY,CAACyB,KAAb,CAAmB;AACxBvB,IAAAA,QAAQ,EAAEA,QAAQ,CAACuB,KAAT,CAAenB,aAAf,CADc;AAExBoB,IAAAA,cAAc,EAAEzB;AAFQ,GAAnB,CAAP;AAID;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAAS0B,eAAT,CAAyBC,UAAzB,EAAqCC,SAArC,EAAgDC,MAAhD,EAAwD;AACtD,MAAIC,YAAJ,CADsD,CACpC;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEAlC,EAAAA,mBAAmB,CAAC+B,UAAD,EAAa;AAChC,YAAUI,CAAV,EAAaC,CAAb,EAAgB;AACd,WAAOD,CAAC,CAACE,SAAF,OAAkBD,CAAC,CAACC,SAAF,EAAzB;AACD,GAHkB,EAGhB;AACH,YAAUC,OAAV,EAAmB;AACjB,WAAOA,OAAO,CAACD,SAAR,OAAwBL,SAA/B;AACD,GANkB,EAMhB;AACH,YAAUO,KAAV,EAAiBC,GAAjB,EAAsB;AACpB;AACA,QAAID,KAAK,IAAIN,MAAT,IAAmBO,GAAG,IAAIP,MAA9B,EAAsC;AACpC;AACAC,MAAAA,YAAY,GAAG;AACbK,QAAAA,KAAK,EAAEA,KADM;AAEbC,QAAAA,GAAG,EAAEA;AAFQ,OAAf;AAID;AACF,GAhBkB,CAAnB;AAiBA,IAAE,OAAON,YAAP,KAAwB,QAA1B,IAAsCO,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC1C,SAAS,CAAC,KAAD,EAAQ,iDAAR,CAAjD,GAA8GA,SAAS,CAAC,KAAD,CAA7J,GAAuK,KAAK,CAA5K;AACA,SAAOiC,YAAP;AACD;;AAED,SAASjB,cAAT,CAAwBV,SAAxB,EAAmCqC,KAAnC,EAA0CX,MAA1C,EAAkD;AAChD,MAAIY,KAAK,GAAGD,KAAK,CAACE,gBAAN,EAAZ;AACA,MAAIC,UAAU,GAAGd,MAAM,GAAG,CAAT,GAAaY,KAAK,CAAC9B,GAAN,CAAUkB,MAAM,GAAG,CAAnB,CAAb,GAAqCe,SAAtD;AACA,MAAIC,SAAS,GAAGhB,MAAM,GAAGY,KAAK,CAACK,KAAN,EAAT,GAAyBL,KAAK,CAAC9B,GAAN,CAAUkB,MAAV,CAAzB,GAA6Ce,SAA7D;AACA,MAAIG,kBAAkB,GAAGJ,UAAU,GAAGA,UAAU,CAACV,SAAX,EAAH,GAA4BW,SAA/D;AACA,MAAII,iBAAiB,GAAGH,SAAS,GAAGA,SAAS,CAACZ,SAAV,EAAH,GAA2BW,SAA5D;;AAEA,MAAII,iBAAiB,IAAIA,iBAAiB,KAAKD,kBAA/C,EAAmE;AACjE,QAAIE,MAAM,GAAG9C,SAAS,CAAC+C,KAAV,CAAgBF,iBAAhB,CAAb;;AAEA,QAAIC,MAAM,CAACE,aAAP,OAA2B,SAA/B,EAA0C;AACxC,UAAIC,gBAAgB,GAAG1B,eAAe,CAACe,KAAD,EAAQO,iBAAR,EAA2BnB,MAA3B,CAAtC;AAAA,UACIM,KAAK,GAAGiB,gBAAgB,CAACjB,KAD7B;AAAA,UAEIC,GAAG,GAAGgB,gBAAgB,CAAChB,GAF3B;;AAIA,UAAIiB,OAAJ;;AAEA,aAAOlB,KAAK,GAAGC,GAAf,EAAoB;AAClBiB,QAAAA,OAAO,GAAGZ,KAAK,CAAC9B,GAAN,CAAUwB,KAAV,CAAV;AACAM,QAAAA,KAAK,GAAGA,KAAK,CAAClB,GAAN,CAAUY,KAAV,EAAiBzC,iBAAiB,CAAC4D,WAAlB,CAA8BD,OAA9B,EAAuC,IAAvC,CAAjB,CAAR;AACAlB,QAAAA,KAAK;AACN;;AAED,aAAOK,KAAK,CAACjB,GAAN,CAAU,eAAV,EAA2BkB,KAA3B,CAAP;AACD;AACF;;AAED,SAAOD,KAAP;AACD;;AAEDe,MAAM,CAACC,OAAP,GAAiB1D,qBAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar CharacterMetadata = require(\"./CharacterMetadata\");\n\nvar findRangesImmutable = require(\"./findRangesImmutable\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nfunction removeEntitiesAtEdges(contentState, selectionState) {\n  var blockMap = contentState.getBlockMap();\n  var entityMap = contentState.getEntityMap();\n  var updatedBlocks = {};\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var startBlock = blockMap.get(startKey);\n  var updatedStart = removeForBlock(entityMap, startBlock, startOffset);\n\n  if (updatedStart !== startBlock) {\n    updatedBlocks[startKey] = updatedStart;\n  }\n\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n  var endBlock = blockMap.get(endKey);\n\n  if (startKey === endKey) {\n    endBlock = updatedStart;\n  }\n\n  var updatedEnd = removeForBlock(entityMap, endBlock, endOffset);\n\n  if (updatedEnd !== endBlock) {\n    updatedBlocks[endKey] = updatedEnd;\n  }\n\n  if (!Object.keys(updatedBlocks).length) {\n    return contentState.set('selectionAfter', selectionState);\n  }\n\n  return contentState.merge({\n    blockMap: blockMap.merge(updatedBlocks),\n    selectionAfter: selectionState\n  });\n}\n/**\n * Given a list of characters and an offset that is in the middle of an entity,\n * returns the start and end of the entity that is overlapping the offset.\n * Note: This method requires that the offset be in an entity range.\n */\n\n\nfunction getRemovalRange(characters, entityKey, offset) {\n  var removalRange; // Iterates through a list looking for ranges of matching items\n  // based on the 'isEqual' callback.\n  // Then instead of returning the result, call the 'found' callback\n  // with each range.\n  // Then filters those ranges based on the 'filter' callback\n  //\n  // Here we use it to find ranges of characters with the same entity key.\n\n  findRangesImmutable(characters, // the list to iterate through\n  function (a, b) {\n    return a.getEntity() === b.getEntity();\n  }, // 'isEqual' callback\n  function (element) {\n    return element.getEntity() === entityKey;\n  }, // 'filter' callback\n  function (start, end) {\n    // 'found' callback\n    if (start <= offset && end >= offset) {\n      // this entity overlaps the offset index\n      removalRange = {\n        start: start,\n        end: end\n      };\n    }\n  });\n  !(typeof removalRange === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Removal range must exist within character list.') : invariant(false) : void 0;\n  return removalRange;\n}\n\nfunction removeForBlock(entityMap, block, offset) {\n  var chars = block.getCharacterList();\n  var charBefore = offset > 0 ? chars.get(offset - 1) : undefined;\n  var charAfter = offset < chars.count() ? chars.get(offset) : undefined;\n  var entityBeforeCursor = charBefore ? charBefore.getEntity() : undefined;\n  var entityAfterCursor = charAfter ? charAfter.getEntity() : undefined;\n\n  if (entityAfterCursor && entityAfterCursor === entityBeforeCursor) {\n    var entity = entityMap.__get(entityAfterCursor);\n\n    if (entity.getMutability() !== 'MUTABLE') {\n      var _getRemovalRange = getRemovalRange(chars, entityAfterCursor, offset),\n          start = _getRemovalRange.start,\n          end = _getRemovalRange.end;\n\n      var current;\n\n      while (start < end) {\n        current = chars.get(start);\n        chars = chars.set(start, CharacterMetadata.applyEntity(current, null));\n        start++;\n      }\n\n      return block.set('characterList', chars);\n    }\n  }\n\n  return block;\n}\n\nmodule.exports = removeEntitiesAtEdges;"]},"metadata":{},"sourceType":"script"}