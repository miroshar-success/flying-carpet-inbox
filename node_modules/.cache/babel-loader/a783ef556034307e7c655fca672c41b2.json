{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n *\n * This is unstable and not part of the public API and should not be used by\n * production systems. This file may be update/removed without notice.\n */\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar DraftTreeInvariants = {\n  /**\n   * Check if the block is valid\n   */\n  isValidBlock: function isValidBlock(block, blockMap) {\n    var key = block.getKey(); // is its parent's child\n\n    var parentKey = block.getParentKey();\n\n    if (parentKey != null) {\n      var parent = blockMap.get(parentKey);\n\n      if (!parent.getChildKeys().includes(key)) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing parent -> child pointer on %s', key) : void 0;\n        return false;\n      }\n    } // is its children's parent\n\n\n    var children = block.getChildKeys().map(function (k) {\n      return blockMap.get(k);\n    });\n\n    if (!children.every(function (c) {\n      return c.getParentKey() === key;\n    })) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing child -> parent pointer on %s', key) : void 0;\n      return false;\n    } // is its previous sibling's next sibling\n\n\n    var prevSiblingKey = block.getPrevSiblingKey();\n\n    if (prevSiblingKey != null) {\n      var prevSibling = blockMap.get(prevSiblingKey);\n\n      if (prevSibling.getNextSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing nextSibling pointer on %s's prevSibling\", key) : void 0;\n        return false;\n      }\n    } // is its next sibling's previous sibling\n\n\n    var nextSiblingKey = block.getNextSiblingKey();\n\n    if (nextSiblingKey != null) {\n      var nextSibling = blockMap.get(nextSiblingKey);\n\n      if (nextSibling.getPrevSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing prevSibling pointer on %s's nextSibling\", key) : void 0;\n        return false;\n      }\n    } // no 2-node cycles\n\n\n    if (nextSiblingKey !== null && prevSiblingKey !== null) {\n      if (prevSiblingKey === nextSiblingKey) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree has a two-node cycle at %s', key) : void 0;\n        return false;\n      }\n    } // if it's a leaf node, it has text but no children\n\n\n    if (block.text != '') {\n      if (block.getChildKeys().size > 0) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Leaf node %s has children', key) : void 0;\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * Checks that this is a connected tree on all the blocks\n   * starting from the first block, traversing nextSibling and child pointers\n   * should be a tree (preorder traversal - parent, then children)\n   * num of connected node === number of blocks\n   */\n  isConnectedTree: function isConnectedTree(blockMap) {\n    // exactly one node has no previous sibling + no parent\n    var eligibleFirstNodes = blockMap.toArray().filter(function (block) {\n      return block.getParentKey() == null && block.getPrevSiblingKey() == null;\n    });\n\n    if (eligibleFirstNodes.length !== 1) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. More or less than one first node') : void 0;\n      return false;\n    }\n\n    var firstNode = eligibleFirstNodes.shift();\n    var nodesSeen = 0;\n    var currentKey = firstNode.getKey();\n    var visitedStack = [];\n\n    while (currentKey != null) {\n      var currentNode = blockMap.get(currentKey);\n      var childKeys = currentNode.getChildKeys();\n      var nextSiblingKey = currentNode.getNextSiblingKey(); // if the node has children, add parent's next sibling to stack and go to children\n\n      if (childKeys.size > 0) {\n        if (nextSiblingKey != null) {\n          visitedStack.unshift(nextSiblingKey);\n        }\n\n        var children = childKeys.map(function (k) {\n          return blockMap.get(k);\n        });\n\n        var _firstNode = children.find(function (block) {\n          return block.getPrevSiblingKey() == null;\n        });\n\n        if (_firstNode == null) {\n          process.env.NODE_ENV !== \"production\" ? warning(true, '%s has no first child', currentKey) : void 0;\n          return false;\n        }\n\n        currentKey = _firstNode.getKey(); // TODO(T32490138): Deal with multi-node cycles here\n      } else {\n        if (currentNode.getNextSiblingKey() != null) {\n          currentKey = currentNode.getNextSiblingKey();\n        } else {\n          currentKey = visitedStack.shift();\n        }\n      }\n\n      nodesSeen++;\n    }\n\n    if (nodesSeen !== blockMap.size) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. %s nodes were seen instead of %s', nodesSeen, blockMap.size) : void 0;\n      return false;\n    }\n\n    return true;\n  },\n\n  /**\n   * Checks that the block map is a connected tree with valid blocks\n   */\n  isValidTree: function isValidTree(blockMap) {\n    var _this = this;\n\n    var blocks = blockMap.toArray();\n\n    if (!blocks.every(function (block) {\n      return _this.isValidBlock(block, blockMap);\n    })) {\n      return false;\n    }\n\n    return this.isConnectedTree(blockMap);\n  }\n};\nmodule.exports = DraftTreeInvariants;","map":{"version":3,"sources":["D:/workspace/flying-assess/flyingcarpet-shared-inbox/node_modules/draft-js/lib/DraftTreeInvariants.js"],"names":["warning","require","DraftTreeInvariants","isValidBlock","block","blockMap","key","getKey","parentKey","getParentKey","parent","get","getChildKeys","includes","process","env","NODE_ENV","children","map","k","every","c","prevSiblingKey","getPrevSiblingKey","prevSibling","getNextSiblingKey","nextSiblingKey","nextSibling","text","size","isConnectedTree","eligibleFirstNodes","toArray","filter","length","firstNode","shift","nodesSeen","currentKey","visitedStack","currentNode","childKeys","unshift","_firstNode","find","isValidTree","_this","blocks","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n *\n * This is unstable and not part of the public API and should not be used by\n * production systems. This file may be update/removed without notice.\n */\nvar warning = require(\"fbjs/lib/warning\");\n\nvar DraftTreeInvariants = {\n  /**\n   * Check if the block is valid\n   */\n  isValidBlock: function isValidBlock(block, blockMap) {\n    var key = block.getKey(); // is its parent's child\n\n    var parentKey = block.getParentKey();\n\n    if (parentKey != null) {\n      var parent = blockMap.get(parentKey);\n\n      if (!parent.getChildKeys().includes(key)) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing parent -> child pointer on %s', key) : void 0;\n        return false;\n      }\n    } // is its children's parent\n\n\n    var children = block.getChildKeys().map(function (k) {\n      return blockMap.get(k);\n    });\n\n    if (!children.every(function (c) {\n      return c.getParentKey() === key;\n    })) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is missing child -> parent pointer on %s', key) : void 0;\n      return false;\n    } // is its previous sibling's next sibling\n\n\n    var prevSiblingKey = block.getPrevSiblingKey();\n\n    if (prevSiblingKey != null) {\n      var prevSibling = blockMap.get(prevSiblingKey);\n\n      if (prevSibling.getNextSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing nextSibling pointer on %s's prevSibling\", key) : void 0;\n        return false;\n      }\n    } // is its next sibling's previous sibling\n\n\n    var nextSiblingKey = block.getNextSiblingKey();\n\n    if (nextSiblingKey != null) {\n      var nextSibling = blockMap.get(nextSiblingKey);\n\n      if (nextSibling.getPrevSiblingKey() !== key) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Tree is missing prevSibling pointer on %s's nextSibling\", key) : void 0;\n        return false;\n      }\n    } // no 2-node cycles\n\n\n    if (nextSiblingKey !== null && prevSiblingKey !== null) {\n      if (prevSiblingKey === nextSiblingKey) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree has a two-node cycle at %s', key) : void 0;\n        return false;\n      }\n    } // if it's a leaf node, it has text but no children\n\n\n    if (block.text != '') {\n      if (block.getChildKeys().size > 0) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, 'Leaf node %s has children', key) : void 0;\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * Checks that this is a connected tree on all the blocks\n   * starting from the first block, traversing nextSibling and child pointers\n   * should be a tree (preorder traversal - parent, then children)\n   * num of connected node === number of blocks\n   */\n  isConnectedTree: function isConnectedTree(blockMap) {\n    // exactly one node has no previous sibling + no parent\n    var eligibleFirstNodes = blockMap.toArray().filter(function (block) {\n      return block.getParentKey() == null && block.getPrevSiblingKey() == null;\n    });\n\n    if (eligibleFirstNodes.length !== 1) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. More or less than one first node') : void 0;\n      return false;\n    }\n\n    var firstNode = eligibleFirstNodes.shift();\n    var nodesSeen = 0;\n    var currentKey = firstNode.getKey();\n    var visitedStack = [];\n\n    while (currentKey != null) {\n      var currentNode = blockMap.get(currentKey);\n      var childKeys = currentNode.getChildKeys();\n      var nextSiblingKey = currentNode.getNextSiblingKey(); // if the node has children, add parent's next sibling to stack and go to children\n\n      if (childKeys.size > 0) {\n        if (nextSiblingKey != null) {\n          visitedStack.unshift(nextSiblingKey);\n        }\n\n        var children = childKeys.map(function (k) {\n          return blockMap.get(k);\n        });\n\n        var _firstNode = children.find(function (block) {\n          return block.getPrevSiblingKey() == null;\n        });\n\n        if (_firstNode == null) {\n          process.env.NODE_ENV !== \"production\" ? warning(true, '%s has no first child', currentKey) : void 0;\n          return false;\n        }\n\n        currentKey = _firstNode.getKey(); // TODO(T32490138): Deal with multi-node cycles here\n      } else {\n        if (currentNode.getNextSiblingKey() != null) {\n          currentKey = currentNode.getNextSiblingKey();\n        } else {\n          currentKey = visitedStack.shift();\n        }\n      }\n\n      nodesSeen++;\n    }\n\n    if (nodesSeen !== blockMap.size) {\n      process.env.NODE_ENV !== \"production\" ? warning(true, 'Tree is not connected. %s nodes were seen instead of %s', nodesSeen, blockMap.size) : void 0;\n      return false;\n    }\n\n    return true;\n  },\n\n  /**\n   * Checks that the block map is a connected tree with valid blocks\n   */\n  isValidTree: function isValidTree(blockMap) {\n    var _this = this;\n\n    var blocks = blockMap.toArray();\n\n    if (!blocks.every(function (block) {\n      return _this.isValidBlock(block, blockMap);\n    })) {\n      return false;\n    }\n\n    return this.isConnectedTree(blockMap);\n  }\n};\nmodule.exports = DraftTreeInvariants;"]},"metadata":{},"sourceType":"script"}