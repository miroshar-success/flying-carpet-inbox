{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar getNextDelimiterBlockKey = require(\"./getNextDelimiterBlockKey\");\n\nvar Immutable = require(\"immutable\");\n\nvar List = Immutable.List,\n    Map = Immutable.Map;\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n/**\n * Ancestors needs to be preserved when there are non selected\n * children to make sure we do not leave any orphans behind\n */\n\n\nvar getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {\n  var parents = [];\n\n  if (!blockKey) {\n    return parents;\n  }\n\n  var blockNode = blockMap.get(blockKey);\n\n  while (blockNode && blockNode.getParentKey()) {\n    var parentKey = blockNode.getParentKey();\n\n    if (parentKey) {\n      parents.push(parentKey);\n    }\n\n    blockNode = parentKey ? blockMap.get(parentKey) : null;\n  }\n\n  return parents;\n};\n/**\n * Get all next delimiter keys until we hit a root delimiter and return\n * an array of key references\n */\n\n\nvar getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {\n  var nextDelimiters = [];\n\n  if (!block) {\n    return nextDelimiters;\n  }\n\n  var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);\n\n  while (nextDelimiter && blockMap.get(nextDelimiter)) {\n    var _block = blockMap.get(nextDelimiter);\n\n    nextDelimiters.push(nextDelimiter); // we do not need to keep checking all root node siblings, just the first occurance\n\n    nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;\n  }\n\n  return nextDelimiters;\n};\n\nvar getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  } // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n\n\n  var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();\n\n  while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {\n    nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;\n  }\n\n  return nextValidSiblingKey;\n};\n\nvar getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  } // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n\n\n  var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();\n\n  while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {\n    prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;\n  }\n\n  return prevValidSiblingKey;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {\n  return blockMap.withMutations(function (blocks) {\n    // update start block if its retained\n    transformBlock(startBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update endblock if its retained\n\n    transformBlock(endBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update start block parent ancestors\n\n    getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      return transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // update start block next - can only happen if startBlock == endBlock\n\n    transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: startBlock.getPrevSiblingKey()\n      });\n    }); // update start block prev\n\n    transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update end block next\n\n    transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update end block prev\n\n    transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: endBlock.getNextSiblingKey()\n      });\n    }); // update end block parent ancestors\n\n    getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // update next delimiters all the way to a root delimiter\n\n    getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {\n      return transformBlock(delimiterKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // if parent (startBlock) was deleted\n\n    if (blockMap.get(startBlock.getKey()) == null && blockMap.get(endBlock.getKey()) != null && endBlock.getParentKey() === startBlock.getKey() && endBlock.getPrevSiblingKey() == null) {\n      var prevSiblingKey = startBlock.getPrevSiblingKey(); // endBlock becomes next sibling of parent's prevSibling\n\n      transformBlock(endBlock.getKey(), blocks, function (block) {\n        return block.merge({\n          prevSibling: prevSiblingKey\n        });\n      });\n      transformBlock(prevSiblingKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: endBlock.getKey()\n        });\n      }); // Update parent for previous parent's children, and children for that parent\n\n      var prevSibling = prevSiblingKey ? blockMap.get(prevSiblingKey) : null;\n      var newParentKey = prevSibling ? prevSibling.getParentKey() : null;\n      startBlock.getChildKeys().forEach(function (childKey) {\n        transformBlock(childKey, blocks, function (block) {\n          return block.merge({\n            parent: newParentKey // set to null if there is no parent\n\n          });\n        });\n      });\n\n      if (newParentKey != null) {\n        var newParent = blockMap.get(newParentKey);\n        transformBlock(newParentKey, blocks, function (block) {\n          return block.merge({\n            children: newParent.getChildKeys().concat(startBlock.getChildKeys())\n          });\n        });\n      } // last child of deleted parent should point to next sibling\n\n\n      transformBlock(startBlock.getChildKeys().find(function (key) {\n        var block = blockMap.get(key);\n        return block.getNextSiblingKey() === null;\n      }), blocks, function (block) {\n        return block.merge({\n          nextSibling: startBlock.getNextSiblingKey()\n        });\n      });\n    }\n  });\n};\n\nvar removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {\n  if (selectionState.isCollapsed()) {\n    return contentState;\n  }\n\n  var blockMap = contentState.getBlockMap();\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n  var startBlock = blockMap.get(startKey);\n  var endBlock = blockMap.get(endKey); // we assume that ContentBlockNode and ContentBlocks are not mixed together\n\n  var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode; // used to retain blocks that should not be deleted to avoid orphan children\n\n  var parentAncestors = [];\n\n  if (isExperimentalTreeBlock) {\n    var endBlockchildrenKeys = endBlock.getChildKeys();\n    var endBlockAncestors = getAncestorsKeys(endKey, blockMap); // endBlock has unselected siblings so we can not remove its ancestors parents\n\n    if (endBlock.getNextSiblingKey()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors);\n    } // endBlock has children so can not remove this block or any of its ancestors\n\n\n    if (!endBlockchildrenKeys.isEmpty()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));\n    } // we need to retain all ancestors of the next delimiter block\n\n\n    parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));\n  }\n\n  var characterList;\n\n  if (startBlock === endBlock) {\n    characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);\n  } else {\n    characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));\n  }\n\n  var modifiedStart = startBlock.merge({\n    text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),\n    characterList: characterList\n  }); // If cursor (collapsed) is at the start of the first child, delete parent\n  // instead of child\n\n  var shouldDeleteParent = isExperimentalTreeBlock && startOffset === 0 && endOffset === 0 && endBlock.getParentKey() === startKey && endBlock.getPrevSiblingKey() == null;\n  var newBlocks = shouldDeleteParent ? Map([[startKey, null]]) : blockMap.toSeq().skipUntil(function (_, k) {\n    return k === startKey;\n  }).takeUntil(function (_, k) {\n    return k === endKey;\n  }).filter(function (_, k) {\n    return parentAncestors.indexOf(k) === -1;\n  }).concat(Map([[endKey, null]])).map(function (_, k) {\n    return k === startKey ? modifiedStart : null;\n  });\n  var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {\n    return !!block;\n  }); // Only update tree block pointers if the range is across blocks\n\n  if (isExperimentalTreeBlock && startBlock !== endBlock) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: startKey,\n      anchorOffset: startOffset,\n      focusKey: startKey,\n      focusOffset: startOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Maintain persistence for target list when removing characters on the\n * head and tail of the character list.\n */\n\n\nvar removeFromList = function removeFromList(targetList, startOffset, endOffset) {\n  if (startOffset === 0) {\n    while (startOffset < endOffset) {\n      targetList = targetList.shift();\n      startOffset++;\n    }\n  } else if (endOffset === targetList.count()) {\n    while (endOffset > startOffset) {\n      targetList = targetList.pop();\n      endOffset--;\n    }\n  } else {\n    var head = targetList.slice(0, startOffset);\n    var tail = targetList.slice(endOffset);\n    targetList = head.concat(tail).toList();\n  }\n\n  return targetList;\n};\n\nmodule.exports = removeRangeFromContentState;","map":{"version":3,"sources":["D:/workspace/flyingcarpet/flyingcarpet-shared-inbox/node_modules/draft-js/lib/removeRangeFromContentState.js"],"names":["ContentBlockNode","require","getNextDelimiterBlockKey","Immutable","List","Map","transformBlock","key","blockMap","func","block","get","set","getAncestorsKeys","blockKey","parents","blockNode","getParentKey","parentKey","push","getNextDelimitersBlockKeys","nextDelimiters","nextDelimiter","_block","getNextValidSibling","originalBlockMap","nextValidSiblingKey","getKey","getNextSiblingKey","getPrevValidSibling","prevValidSiblingKey","getPrevSiblingKey","updateBlockMapLinks","startBlock","endBlock","withMutations","blocks","merge","nextSibling","prevSibling","forEach","children","getChildKeys","filter","delimiterKey","prevSiblingKey","newParentKey","childKey","parent","newParent","concat","find","removeRangeFromContentState","contentState","selectionState","isCollapsed","getBlockMap","startKey","getStartKey","startOffset","getStartOffset","endKey","getEndKey","endOffset","getEndOffset","isExperimentalTreeBlock","parentAncestors","endBlockchildrenKeys","endBlockAncestors","isEmpty","characterList","removeFromList","getCharacterList","slice","modifiedStart","text","getText","shouldDeleteParent","newBlocks","toSeq","skipUntil","_","k","takeUntil","indexOf","map","updatedBlockMap","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","targetList","shift","count","pop","head","tail","toList","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar getNextDelimiterBlockKey = require(\"./getNextDelimiterBlockKey\");\n\nvar Immutable = require(\"immutable\");\n\nvar List = Immutable.List,\n    Map = Immutable.Map;\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n/**\n * Ancestors needs to be preserved when there are non selected\n * children to make sure we do not leave any orphans behind\n */\n\n\nvar getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {\n  var parents = [];\n\n  if (!blockKey) {\n    return parents;\n  }\n\n  var blockNode = blockMap.get(blockKey);\n\n  while (blockNode && blockNode.getParentKey()) {\n    var parentKey = blockNode.getParentKey();\n\n    if (parentKey) {\n      parents.push(parentKey);\n    }\n\n    blockNode = parentKey ? blockMap.get(parentKey) : null;\n  }\n\n  return parents;\n};\n/**\n * Get all next delimiter keys until we hit a root delimiter and return\n * an array of key references\n */\n\n\nvar getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {\n  var nextDelimiters = [];\n\n  if (!block) {\n    return nextDelimiters;\n  }\n\n  var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);\n\n  while (nextDelimiter && blockMap.get(nextDelimiter)) {\n    var _block = blockMap.get(nextDelimiter);\n\n    nextDelimiters.push(nextDelimiter); // we do not need to keep checking all root node siblings, just the first occurance\n\n    nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;\n  }\n\n  return nextDelimiters;\n};\n\nvar getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  } // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n\n\n  var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();\n\n  while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {\n    nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;\n  }\n\n  return nextValidSiblingKey;\n};\n\nvar getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  } // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n\n\n  var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();\n\n  while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {\n    prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;\n  }\n\n  return prevValidSiblingKey;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {\n  return blockMap.withMutations(function (blocks) {\n    // update start block if its retained\n    transformBlock(startBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update endblock if its retained\n\n    transformBlock(endBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update start block parent ancestors\n\n    getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      return transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // update start block next - can only happen if startBlock == endBlock\n\n    transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: startBlock.getPrevSiblingKey()\n      });\n    }); // update start block prev\n\n    transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update end block next\n\n    transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n      });\n    }); // update end block prev\n\n    transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: endBlock.getNextSiblingKey()\n      });\n    }); // update end block parent ancestors\n\n    getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // update next delimiters all the way to a root delimiter\n\n    getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {\n      return transformBlock(delimiterKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // if parent (startBlock) was deleted\n\n    if (blockMap.get(startBlock.getKey()) == null && blockMap.get(endBlock.getKey()) != null && endBlock.getParentKey() === startBlock.getKey() && endBlock.getPrevSiblingKey() == null) {\n      var prevSiblingKey = startBlock.getPrevSiblingKey(); // endBlock becomes next sibling of parent's prevSibling\n\n      transformBlock(endBlock.getKey(), blocks, function (block) {\n        return block.merge({\n          prevSibling: prevSiblingKey\n        });\n      });\n      transformBlock(prevSiblingKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: endBlock.getKey()\n        });\n      }); // Update parent for previous parent's children, and children for that parent\n\n      var prevSibling = prevSiblingKey ? blockMap.get(prevSiblingKey) : null;\n      var newParentKey = prevSibling ? prevSibling.getParentKey() : null;\n      startBlock.getChildKeys().forEach(function (childKey) {\n        transformBlock(childKey, blocks, function (block) {\n          return block.merge({\n            parent: newParentKey // set to null if there is no parent\n\n          });\n        });\n      });\n\n      if (newParentKey != null) {\n        var newParent = blockMap.get(newParentKey);\n        transformBlock(newParentKey, blocks, function (block) {\n          return block.merge({\n            children: newParent.getChildKeys().concat(startBlock.getChildKeys())\n          });\n        });\n      } // last child of deleted parent should point to next sibling\n\n\n      transformBlock(startBlock.getChildKeys().find(function (key) {\n        var block = blockMap.get(key);\n        return block.getNextSiblingKey() === null;\n      }), blocks, function (block) {\n        return block.merge({\n          nextSibling: startBlock.getNextSiblingKey()\n        });\n      });\n    }\n  });\n};\n\nvar removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {\n  if (selectionState.isCollapsed()) {\n    return contentState;\n  }\n\n  var blockMap = contentState.getBlockMap();\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n  var startBlock = blockMap.get(startKey);\n  var endBlock = blockMap.get(endKey); // we assume that ContentBlockNode and ContentBlocks are not mixed together\n\n  var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode; // used to retain blocks that should not be deleted to avoid orphan children\n\n  var parentAncestors = [];\n\n  if (isExperimentalTreeBlock) {\n    var endBlockchildrenKeys = endBlock.getChildKeys();\n    var endBlockAncestors = getAncestorsKeys(endKey, blockMap); // endBlock has unselected siblings so we can not remove its ancestors parents\n\n    if (endBlock.getNextSiblingKey()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors);\n    } // endBlock has children so can not remove this block or any of its ancestors\n\n\n    if (!endBlockchildrenKeys.isEmpty()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));\n    } // we need to retain all ancestors of the next delimiter block\n\n\n    parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));\n  }\n\n  var characterList;\n\n  if (startBlock === endBlock) {\n    characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);\n  } else {\n    characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));\n  }\n\n  var modifiedStart = startBlock.merge({\n    text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),\n    characterList: characterList\n  }); // If cursor (collapsed) is at the start of the first child, delete parent\n  // instead of child\n\n  var shouldDeleteParent = isExperimentalTreeBlock && startOffset === 0 && endOffset === 0 && endBlock.getParentKey() === startKey && endBlock.getPrevSiblingKey() == null;\n  var newBlocks = shouldDeleteParent ? Map([[startKey, null]]) : blockMap.toSeq().skipUntil(function (_, k) {\n    return k === startKey;\n  }).takeUntil(function (_, k) {\n    return k === endKey;\n  }).filter(function (_, k) {\n    return parentAncestors.indexOf(k) === -1;\n  }).concat(Map([[endKey, null]])).map(function (_, k) {\n    return k === startKey ? modifiedStart : null;\n  });\n  var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {\n    return !!block;\n  }); // Only update tree block pointers if the range is across blocks\n\n  if (isExperimentalTreeBlock && startBlock !== endBlock) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: startKey,\n      anchorOffset: startOffset,\n      focusKey: startKey,\n      focusOffset: startOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Maintain persistence for target list when removing characters on the\n * head and tail of the character list.\n */\n\n\nvar removeFromList = function removeFromList(targetList, startOffset, endOffset) {\n  if (startOffset === 0) {\n    while (startOffset < endOffset) {\n      targetList = targetList.shift();\n      startOffset++;\n    }\n  } else if (endOffset === targetList.count()) {\n    while (endOffset > startOffset) {\n      targetList = targetList.pop();\n      endOffset--;\n    }\n  } else {\n    var head = targetList.slice(0, startOffset);\n    var tail = targetList.slice(endOffset);\n    targetList = head.concat(tail).toList();\n  }\n\n  return targetList;\n};\n\nmodule.exports = removeRangeFromContentState;"]},"metadata":{},"sourceType":"script"}